#include <stm32f4xx_cus_timer.h>

volatile uint32_t mil = 0;

void TIM_INIT(TIM_HandleTypeDef *timHandleTypeDef) {
	if (timHandleTypeDef->TIMx == TIM2) {
		TIM2_EN();
	} else if (timHandleTypeDef->TIMx == TIM3) {
		TIM3_EN();
	} else if (timHandleTypeDef->TIMx == TIM4) {
		TIM4_EN();
	} else if (timHandleTypeDef->TIMx == TIM5) {
		TIM5_EN();
	}

	// Ensure Counter is disable
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_0_pos);

	// Clock prescaler
	timHandleTypeDef->TIMx->PSC = timHandleTypeDef->prescaler;

	// Select Auto-reload value
	timHandleTypeDef->TIMx->ARR = timHandleTypeDef->autoReload;

	/*	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
	 TIM2->ARR = 1000;  // New value is buffered
	 // Counter continues using old ARR value until next overflow
	 // At next update event, ARR = 1000 takes effect
	 ```

	 ## Visual Example
	 ```
	 Without Preload:
	 CNT: 0 → 500 → 999 → 1000 (overflow)
	 You write ARR = 500 while CNT = 750
	 CNT: 750 → 751 → ... → 65535 → 0 → ... → 500 (finally overflows!) ❌

	 With Preload:
	 CNT: 0 → 500 → 999 → 1000 (overflow, new ARR loaded)
	 You write ARR = 500 while CNT = 750
	 CNT: 750 → 999 → 1000 (overflow with old ARR)
	 0 → 499 → 500 (now using new ARR) ✓*/

	// autoReloadPreload
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_7_pos);
	timHandleTypeDef->TIMx->CR1 |= (timHandleTypeDef->autoReloadPreload
			<< Shift_7_pos);

	// Select direction counter
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_4_pos);
	timHandleTypeDef->TIMx->CR1 |= (timHandleTypeDef->directionCounter
			<< Shift_4_pos);

	// Update disable
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_1_pos);
	timHandleTypeDef->TIMx->CR1 |= (timHandleTypeDef->updateDisable
			<< Shift_1_pos);

	// Update request source (Select source)
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_2_pos);
	timHandleTypeDef->TIMx->CR1 |= (timHandleTypeDef->updateRequestSource
			<< Shift_2_pos);

	// Timer enable
	timHandleTypeDef->TIMx->CR1 |= (HIGH << Shift_0_pos);

	/*	UG: Update generation
	 This bit can be set by software, it is automatically cleared by hardware.
	 0: No action
	 1: Re-initialize the counter and generates an update of the registers.*/
	timHandleTypeDef->TIMx->EGR |= (HIGH << Shift_0_pos);

	// Clear the update flag that was just set
	timHandleTypeDef->TIMx->SR &= ~(HIGH << Shift_0_pos);
}

void TIM_ENABLE(TIM_HandleTypeDef *timHandleTypeDef) {
	// Timer enable
	timHandleTypeDef->TIMx->CR1 |= (HIGH << Shift_0_pos);

	/*	UG: Update generation
	 This bit can be set by software, it is automatically cleared by hardware.
	 0: No action
	 1: Re-initialize the counter and generates an update of the registers.*/
	timHandleTypeDef->TIMx->EGR |= (HIGH << Shift_0_pos);

	// Clear the update flag that was just set
	timHandleTypeDef->TIMx->SR &= ~(HIGH << Shift_0_pos);
}

void TIM_DELAY_INIT(TIM_HandleTypeDef *timHandleTypeDef) {
	if (timHandleTypeDef->TIMx == TIM2) {
		TIM2_EN();
	} else if (timHandleTypeDef->TIMx == TIM3) {
		TIM3_EN();
	} else if (timHandleTypeDef->TIMx == TIM4) {
		TIM4_EN();
	} else if (timHandleTypeDef->TIMx == TIM5) {
		TIM5_EN();
	}

	Get_APB1_Clock_Speed();

	uint32_t psc = SystemClockSrc / ONE_MEGA_HERT;

	// Ensure Counter is disable
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_0_pos);

	// Clock prescaler
	timHandleTypeDef->TIMx->PSC = (psc - 1);

	// Select Auto-reload value (This will generate interrupt every 1ms for millis, but if use delay fuction then this ARR actually don't care)
	timHandleTypeDef->TIMx->ARR = 999;

	// autoReloadPreload
	timHandleTypeDef->TIMx->CR1 |= (HIGH << Shift_7_pos);

	// Count up
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_4_pos);

	// Enable update
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_1_pos);

	// Update request source (Select source)
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_2_pos);

	if (timHandleTypeDef->timerMode == TIM_INPUT_CAPTURE_MODE) {
		if (timHandleTypeDef->TIM_IC_HandleTypeDef.channel == TIM_CHANNEL_1) {
			// Capture/Compare 1 selection
			timHandleTypeDef->TIMx->CCMR1 &= ~(GPIO_BIT_11_Mask << Shift_0_pos);
			timHandleTypeDef->TIMx->CCMR1 |=
					(timHandleTypeDef->TIM_IC_HandleTypeDef.selection
							<< Shift_0_pos);

			// Input capture 1 prescaler
			timHandleTypeDef->TIMx->CCMR1 &= ~(GPIO_BIT_11_Mask << Shift_2_pos);
			timHandleTypeDef->TIMx->CCMR1 |=
					(timHandleTypeDef->TIM_IC_HandleTypeDef.prescaler
							<< Shift_2_pos);

			// Input capture 1 filter
			timHandleTypeDef->TIMx->CCMR1 &= ~(0xF << Shift_4_pos);
			timHandleTypeDef->TIMx->CCMR1 |=
					(timHandleTypeDef->TIM_IC_HandleTypeDef.filter
							<< Shift_4_pos);

			// CC1P: Capture/Compare 1 output Polarity.
			timHandleTypeDef->TIMx->CCER &= ~(0x3 << Shift_1_pos);
			timHandleTypeDef->TIMx->CCER |=
					(timHandleTypeDef->TIM_IC_HandleTypeDef.polarity
							<< Shift_1_pos);

			// CC1NP: Capture/Compare 1 output Polarity.
			/*			CC1 channel configured as input:
			 This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.*/

			//   CC1E: Capture/Compare 1 output enable.
			timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_0_pos);

		} else if (timHandleTypeDef->TIM_IC_HandleTypeDef.channel
				== TIM_CHANNEL_2) {
			// Capture/Compare 2 selection
			timHandleTypeDef->TIMx->CCMR1 &= ~(GPIO_BIT_11_Mask << Shift_0_pos);
			timHandleTypeDef->TIMx->CCMR1 |=
					(timHandleTypeDef->TIM_IC_HandleTypeDef.selection
							<< Shift_0_pos);

			// Input capture 1 prescaler
			timHandleTypeDef->TIMx->CCMR1 &= ~(GPIO_BIT_11_Mask << Shift_2_pos);
			timHandleTypeDef->TIMx->CCMR1 |=
					(timHandleTypeDef->TIM_IC_HandleTypeDef.prescaler
							<< Shift_2_pos);

			// Input capture 1 filter
			timHandleTypeDef->TIMx->CCMR1 &= ~(0xF << Shift_4_pos);
			timHandleTypeDef->TIMx->CCMR1 |=
					(timHandleTypeDef->TIM_IC_HandleTypeDef.filter
							<< Shift_4_pos);

			// CC1P: Capture/Compare 1 output Polarity.
			timHandleTypeDef->TIMx->CCER &= ~(0x3 << Shift_1_pos);
			timHandleTypeDef->TIMx->CCER |=
					(timHandleTypeDef->TIM_IC_HandleTypeDef.polarity
							<< Shift_1_pos);

			// CC1NP: Capture/Compare 1 output Polarity.
			/*			CC1 channel configured as input:
			 This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.*/

			//   CC1E: Capture/Compare 1 output enable.
			timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_0_pos);

		} else if (timHandleTypeDef->TIM_IC_HandleTypeDef.channel
				== TIM_CHANNEL_3) {

		} else if (timHandleTypeDef->TIM_IC_HandleTypeDef.channel
				== TIM_CHANNEL_4) {
		}
	}
}

void TIM_MILLIS_INIT(TIM_HandleTypeDef *timHandleTypeDef) {
	TIM_DELAY_INIT(timHandleTypeDef);
	timHandleTypeDef->TIMx->DIER |= (HIGH << Shift_0_pos);

	if (timHandleTypeDef->TIMx == TIM2) {
		IRQ_Config(TIM2_IRQ28, HIGH);
	} else if (timHandleTypeDef->TIMx == TIM3) {
		IRQ_Config(TIM3_IRQ29, HIGH);
	} else if (timHandleTypeDef->TIMx == TIM4) {
		IRQ_Config(TIM4_IRQ30, HIGH);
	} else if (timHandleTypeDef->TIMx == TIM5) {
		IRQ_Config(TIM5_IRQ50, HIGH);
	}
}

uint32_t millis() {
	return mil;
}

void TIM_Handling(TIM_HandleTypeDef *timHandleTypeDef) {
	if (((timHandleTypeDef->TIMx->SR) >> Shift_0_pos) & 0x1) {
		// Clear the update flag that was just set
		timHandleTypeDef->TIMx->SR &= ~(HIGH << Shift_0_pos);
		mil++;
	}
}

void delay_us(TIM_HandleTypeDef *timHandleTypeDef, uint32_t us) {
	timHandleTypeDef->TIMx->CNT = 0;

	while (timHandleTypeDef->TIMx->CNT < us)
		;
}

void delay_ms(TIM_HandleTypeDef *timHandleTypeDef, uint32_t ms) {
	for (uint32_t i = 0; i < ms; i++) {
		delay_us(timHandleTypeDef, 1000);
	}
}
