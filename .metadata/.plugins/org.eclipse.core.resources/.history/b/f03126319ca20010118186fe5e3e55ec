#include <stm32f4xx_cus_uart.h>

void USART_INIT(USART_HandleTypedef *usart_handle) {
	if (usart_handle->USARTx == USART1) {
		USART1_EN();
	} else if (usart_handle->USARTx == USART2) {
		USART2_EN();
	} else if (usart_handle->USARTx == USART3) {
		USART3_EN();
	} else if (usart_handle->USARTx == UART4) {
		UART4_EN();
	} else if (usart_handle->USARTx == UART5) {
		UART5_EN();
	} else if (usart_handle->USARTx == USART6) {
		USART6_EN();
	} else if (usart_handle->USARTx == UART7) {
		UART7_EN();
	} else if (usart_handle->USARTx == UART8) {
		UART8_EN();
	}

	// Enable FPU - CRITICAL for floating point operations
	SCB->CPACR |= ((3UL << 20) | (3UL << 22)); // Set CP10 and CP11 to Full Access
	__asm volatile ("DSB");
	// Data Synchronization Barrier
	__asm volatile ("ISB");
	// Instruction Synchronization Barrier

	float USARTDIV = (float) 16000000.0f
			/ (8.0f * (2 - usart_handle->oversampling_mode)
					* usart_handle->baud_rate);

	// Extract mantissa (integer part)
	uint16_t DIV_Mantissa = (uint16_t) USARTDIV;

	// Extract fraction and Round it to the nearest value
	// For example: 9.92 + 0.5 = 10.42 --> Round to 10;
	uint16_t DIV_Fraction = (uint16_t) ((USARTDIV - DIV_Mantissa) * 8
			* (2 - usart_handle->oversampling_mode) + 0.5f);

	// // Handle fraction overflow
	if (usart_handle->oversampling_mode == USART_OVERSAMPLING_16) {
		if (DIV_Fraction > 15) {
			DIV_Mantissa++;
			DIV_Fraction = 0;
		}
	} else {
		if (DIV_Fraction > 7) {
			DIV_Mantissa++;
			DIV_Fraction = 0;
		}
	}

	usart_handle->USARTx->CR1 &= ~(HIGH << Shift_15_pos);
	usart_handle->USARTx->CR1 |= (usart_handle->oversampling_mode
			<< Shift_15_pos);

	usart_handle->USARTx->BRR = 0;
	usart_handle->USARTx->BRR |= (DIV_Fraction << Shift_0_pos);
	usart_handle->USARTx->BRR |= (DIV_Mantissa << Shift_4_pos);

	usart_handle->USARTx->CR1 &= ~(HIGH << Shift_12_pos);
	usart_handle->USARTx->CR1 |= (usart_handle->data_bits << Shift_12_pos);

	usart_handle->USARTx->CR1 &= ~(HIGH << Shift_10_pos);
	usart_handle->USARTx->CR1 |= (usart_handle->parity_control << Shift_10_pos);

	if (usart_handle->parity_control == USART_PARITY_ENABLE) {
		usart_handle->USARTx->CR1 &= ~(HIGH << Shift_9_pos);
		usart_handle->USARTx->CR1 |= (usart_handle->parity_selection
				<< Shift_9_pos);
	}

	usart_handle->USARTx->CR2 &= ~(GPIO_BIT_11_Mask << Shift_12_pos);
	usart_handle->USARTx->CR2 |= (usart_handle->stop_bits << Shift_12_pos);

	// Clock Synchronous Enable or Not
	usart_handle->USARTx->CR2 &= ~(HIGH << Shift_11_pos);
	usart_handle->USARTx->CR2 |= (usart_handle->usart_mode << Shift_11_pos);

	if (usart_handle->usart_mode == USART_MODE_SYNC) {
		usart_handle->USARTx->CR2 &= ~(BIT_111_MASK << Shift_8_pos);
		usart_handle->USARTx->CR2 |= (usart_handle->last_bit_clock_pulse
				<< Shift_8_pos);
		usart_handle->USARTx->CR2 |= (usart_handle->usart_cpha << Shift_9_pos);
		usart_handle->USARTx->CR2 |= (usart_handle->usart_cpol << Shift_10_pos);
	}

	// Hardware control flow
	usart_handle->USARTx->CR3 &= ~(GPIO_BIT_11_Mask << Shift_8_pos);
	if (usart_handle->usart_hardware_flow_control != USART_HW_FLOW_CTRL_NONE) {
		usart_handle->USARTx->CR3 |= (usart_handle->usart_hardware_flow_control
				<< 8);
	}

	// Enable Peripheral
	USART_ENABLE(usart_handle, HIGH);
}

void USART_ENABLE(USART_HandleTypedef *usart_handle, uint8_t EnOrDis) {
	if (EnOrDis == HIGH) {
		usart_handle->USARTx->CR1 |= (EnOrDis << Shift_13_pos);
	} else {
		usart_handle->USARTx->CR1 &= ~(HIGH << Shift_13_pos);
	}
}

void UART_TRANSMIT_ENABLE(USART_HandleTypedef *usart_handle, uint8_t EnOrDis) {
	if (EnOrDis == HIGH) {
		usart_handle->USARTx->CR1 |= (EnOrDis << Shift_3_pos);
	} else {
		usart_handle->USARTx->CR1 &= ~(HIGH << Shift_3_pos);
	}
}

void USART_write(USART_HandleTypedef *usart_handle, uint8_t *data,
		uint32_t size) {
	uint16_t *pData;
	UART_TRANSMIT_ENABLE(usart_handle, HIGH);
	for (uint32_t i = 0; i < size; i++) {
		// Wait for TXE is empty
		while (!((usart_handle->USARTx->SR >> Shift_7_pos) & 0x1))
			;
		// When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register),
		// the value written in the MSB (bit 7 or bit 8 depending on the data length)
		// has no effect because it is replaced by the parity.
		if (usart_handle->data_bits == USART_9_DATA_BITS) {
			pData = (uint16_t*) data;
			usart_handle->USARTx->DR = (*pData & 0x1FF); // Write 9-bit data
			if (usart_handle->parity_control == USART_PARITY_ENABLE) {
				data++;
				data++;
			} else {
				data++;
			}
		} else {
			usart_handle->USARTx->DR = (*data & 0xFF); // Write 8-bit data
			data++;
		}
	}

	// Wait for Transmission complete
	while (!((usart_handle->USARTx->SR >> Shift_6_pos) & 0x1))
		;

	UART_TRANSMIT_ENABLE(usart_handle, LOW);
}

