#include "stm32f4xx_cus.h"
#include "stm32f4xx_cus_gpio.h"
#include "stm32f4xx_cus_can.h"
#include <stdio.h>  // For printf

// Function prototypes
void CAN_GPIO_Init(void);
void Test_Silent_Mode(void);
void delay_ms(uint32_t ms);

int main(void) {
	// Run CAN loopback test
	Test_Silent_Mode();

	while (1) {
		// Main loop - test runs in Test_Loopback_Mode
	}
}

void CAN_GPIO_Init(void) {
	// Configure PD0 (CAN1_RX) and PD1 (CAN1_TX)
	GPIO_Handle_TypeDef canTxPin;
	canTxPin.GPIOX = GPIOD;
	canTxPin.pin_number = GPIO_PIN_1; // CAN1_TX = PD1
	canTxPin.mode = GPIO_MODE_AF; // Alternate function
	canTxPin.alternate_function_select = GPIO_AF9; // AF9 = CAN1
	canTxPin.output_type = GPIO_OUTPUT_TYPE_PP; // Push-pull
	canTxPin.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH; // Very high speed
	canTxPin.pull_up_pull_down = GPIO_PUPD_PU; // Pull-up
	GPIO_INIT(&canTxPin);

	GPIO_Handle_TypeDef canRxPin;
	canRxPin.GPIOX = GPIOD;
	canRxPin.pin_number = GPIO_PIN_0; // CAN1_RX = PD0
	canRxPin.mode = GPIO_MODE_AF; // Alternate function
	canRxPin.alternate_function_select = GPIO_AF9; // AF9 = CAN1
	canRxPin.output_type = GPIO_OUTPUT_TYPE_PP; // Push-pull (not used for input but set anyway)
	canRxPin.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH; // Very high speed
	canRxPin.pull_up_pull_down = GPIO_PUPD_PU; // Pull-up
	GPIO_INIT(&canRxPin);
}

void Test_Loopback_Mode(void) {
	// Step 1: Initialize GPIO
	CAN_GPIO_Init();

	// Step 2: Configure CAN handle
	CAN_HandleTypedef canHandle;
	canHandle.CANx = CAN1;
	canHandle.transmitPriority = 0; // Priority by request order
	canHandle.receiveFIFOLockedMode = 0; // Overwrite mode (not locked)
	canHandle.autoReTransmit = 1; // Disable auto retransmission
	canHandle.autoBusOff = 1; // Enable auto bus-off management
	canHandle.bitrate = 1000000; // 500 kbps
	canHandle.testModeSelected = CAN_SILENT_MODE; // Loopback mode

	// Step 3: Initialize CAN peripheral
	CAN_INIT(&canHandle);

	// Step 4: Configure filter to accept all messages
	CAN_FilterHandleTypeDef filterConfig;
	filterConfig.filterBank = 0;
	filterConfig.filterScale = CAN_FILTER_32_BIT_SCALE;
	filterConfig.filterMaskListMode = CAN_ID_MASK_MODE;
	filterConfig.extd = CAN_STANDARD_IDE;
	filterConfig.fifoAssignment = CAN_FIFO_0;

	// Accept all messages (ID = 0x000, Mask = 0x000)
	filterConfig.CAN_Filter32BitMaskHandleTypeDef.id1 = 0x000;
	filterConfig.CAN_Filter32BitMaskHandleTypeDef.mask1 = 0x000;

	CAN_FILTER_CONFIG(&canHandle, &filterConfig);

	// Step 5: Test loop - continuous send and receive
	uint32_t messageCount = 0;

	printf("CAN Loopback Test Started\r\n");
	printf("==========================\r\n\r\n");

	while (1) {
//		// Prepare TX message
//		CAN_TXHandleTypeDef txMsg;
//		txMsg.identifier = 0x123;
//		txMsg.extd = CAN_STANDARD_IDE;
//		txMsg.frameType = CAN_DATA_FRAME;
//		txMsg.dataLengthCode = 8;
//
//		// Fill data with pattern
//		txMsg.data[0] = 0xAA;
//		txMsg.data[1] = 0xBB;
//		txMsg.data[2] = 0xCC;
//		txMsg.data[3] = 0xDD;
//		txMsg.data[4] = 0x01;
//		txMsg.data[5] = 0x02;
//		txMsg.data[6] = 0x03;
//		txMsg.data[7] = 0x04;
//
//		// Send message
//		printf("Sending CAN message #%lu...\r\n", ++messageCount);
//		CAN_SEND(&canHandle, &txMsg);

		// Small delay to allow transmission to complete
		delay_ms(10);

		// Check for received messages
		uint8_t msgPending = CAN_RX_FREE_LEVEL(&canHandle, CAN_FIFO_0);

		if (msgPending > 0) {
			CAN_RXHandleTypeDef rxMsg;
			uint8_t status = CAN_RECEIVE(&canHandle, &rxMsg, CAN_FIFO_0);

			if (status == CAN_RCV_SUCCESS) {
				// Print received message details
				printf("âœ“ Message received successfully!\r\n");
				printf("  ID: 0x%03lX\r\n", rxMsg.identifier);
				printf("  Type: %s\r\n",
						rxMsg.extd == CAN_STANDARD_IDE ?
								"Standard" : "Extended");
				printf("  Frame: %s\r\n", rxMsg.rtr ? "Remote" : "Data");
				printf("  DLC: %d\r\n", rxMsg.dataLengthCode);
				printf("  Data: ");

				for (uint8_t i = 0; i < rxMsg.dataLengthCode; i++) {
					printf("0x%02X ", rxMsg.data[i]);
				}
				printf("\r\n");

				// Verify data
				uint8_t dataMatch = 1;
				for (uint8_t i = 0; i < rxMsg.dataLengthCode; i++) {
					if (rxMsg.data[i] != txMsg.data[i]) {
						dataMatch = 0;
						break;
					}
				}

				if (dataMatch && rxMsg.identifier == txMsg.identifier) {
					printf("Data verification: PASSED\r\n");
				} else {
					printf("Data verification: FAILED\r\n");
				}
			} else {
				printf("Failed to receive message\r\n");
			}
		} else {
			printf("No message pending in FIFO\r\n");
		}

		printf("\r\n");

		// Delay between messages (1 second)
		delay_ms(1000);
	}
}

void delay_ms(uint32_t ms) {
	// Rough delay - adjust based on your system clock
	// Assumes ~16 MHz clock, ~4 cycles per loop iteration
	for (uint32_t i = 0; i < ms; i++) {
		for (volatile uint32_t j = 0; j < 4000; j++)
			;
	}
}
