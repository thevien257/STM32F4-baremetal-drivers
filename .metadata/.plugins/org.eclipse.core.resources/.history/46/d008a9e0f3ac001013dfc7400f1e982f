#include <stdint.h>
#include "stm32f4xx_cus.h"
#include "stm32f4xx_cus_gpio.h"
#include "stm32f4xx_cus_can.h"
#include <stdio.h>

// =============================
// Function prototypes
// =============================
void CAN_GPIO_Init(void);
void CAN_IT_Mode_Init(void);
void GPIO_USER_INIT(void);
void delay_ms(uint32_t ms);

// Global CAN handle
CAN_HandleTypedef canHandle;
GPIO_Handle_TypeDef GPIO_Handle;

int main(void) {
	// Initialize GPIO (button)
	GPIO_USER_INIT();

	// Enable CAN1 TX interrupt
	IRQ_Config(CAN1_TX_IRQ19, ENABLE);

	// Initialize CAN in interrupt mode
	CAN_IT_Mode_Init();

	printf("STM32 CAN Interrupt Mode Started\r\n");
	printf("Press button to send CAN message\r\n");
	printf("==============================\r\n\r\n");

	uint32_t messageCount = 0;

	while (1) {

		// Prepare TX message
		CAN_TXHandleTypeDef txMsg;
		txMsg.identifier = 0x123;
		txMsg.extd = CAN_STANDARD_IDE;
		txMsg.frameType = CAN_DATA_FRAME;
		txMsg.dataLengthCode = 8;

		// Fill data pattern
		txMsg.data[0] = 0xAA;
		txMsg.data[1] = 0xBB;
		txMsg.data[2] = 0xCC;
		txMsg.data[3] = 0xDD;
		txMsg.data[4] = 0xEE;
		txMsg.data[5] = 0x1;
		txMsg.data[6] = 0x2;
		txMsg.data[7] = 0x3;

		printf("Sending CAN message #%lu (Interrupt Mode)...\r\n",
				++messageCount);

		// Reset completion flag
		CAN_txCompl = LOW;

		// Send using interrupt mode
		CAN_SEND_IT(&canHandle, &txMsg);

		// Wait for transmission to complete
		while (CAN_txCompl != HIGH)
			;

		printf("Message sent successfully via interrupt!\r\n\r\n");

	}
}

// =============================
// GPIO Configuration for CAN (PD0, PD1)
// =============================
void CAN_GPIO_Init(void) {
	GPIO_Handle_TypeDef canTxPin;
	canTxPin.GPIOX = GPIOD;
	canTxPin.pin_number = GPIO_PIN_1;              // CAN1_TX = PD1
	canTxPin.mode = GPIO_MODE_AF;
	canTxPin.alternate_function_select = GPIO_AF9; // AF9 = CAN1
	canTxPin.output_type = GPIO_OUTPUT_TYPE_PP;
	canTxPin.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
	canTxPin.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&canTxPin);

	GPIO_Handle_TypeDef canRxPin;
	canRxPin.GPIOX = GPIOD;
	canRxPin.pin_number = GPIO_PIN_0;              // CAN1_RX = PD0
	canRxPin.mode = GPIO_MODE_AF;
	canRxPin.alternate_function_select = GPIO_AF9; // AF9 = CAN1
	canRxPin.output_type = GPIO_OUTPUT_TYPE_PP;
	canRxPin.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
	canRxPin.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&canRxPin);
}

// =============================
// CAN Interrupt Mode Initialization
// =============================
void CAN_IT_Mode_Init(void) {
	// Step 1: Init GPIO
	CAN_GPIO_Init();

	// Step 2: Configure CAN parameters
	canHandle.CANx = CAN1;
	canHandle.transmitPriority = 0;
	canHandle.receiveFIFOLockedMode = 0;
	canHandle.autoReTransmit = 1;
	canHandle.autoBusOff = 1;
	canHandle.bitrate = 1000000;                    // 1000 kbps
	canHandle.testModeSelected = CAN_NORMAL_MODE;

	// Step 3: Init CAN
	CAN_INIT(&canHandle);

	// Step 4: Configure filter to accept all frames
	CAN_FilterHandleTypeDef filterConfig;
	filterConfig.filterBank = 0;
	filterConfig.extd = CAN_STANDARD_IDE;
	filterConfig.fifoAssignment = CAN_FIFO_0;
	filterConfig.filterScale = CAN_FILTER_32_BIT_SCALE;
	filterConfig.filterMaskListMode = CAN_ID_MASK_MODE;
	filterConfig.CAN_Filter32BitMaskHandleTypeDef.id1 = 0x000;
	filterConfig.CAN_Filter32BitMaskHandleTypeDef.mask1 = 0x000; // Accept all IDs

	CAN_FILTER_CONFIG(&canHandle, &filterConfig);

	printf("CAN initialized in INTERRUPT mode\r\n");
	printf("Bitrate: 1000 kbps\r\n");
	printf("Mode: Loopback\r\n\r\n");
}

// =============================
// GPIO Button Configuration (PA0)
// =============================
void GPIO_USER_INIT(void) {
	// PA0 - USER BUTTON
	GPIO_Handle.GPIOX = GPIOA;
	GPIO_Handle.mode = GPIO_MODE_INPUT;
	GPIO_Handle.pin_number = GPIO_PIN_0;
	GPIO_Handle.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&GPIO_Handle);
}

// =============================
// CAN1 TX Interrupt Handler
// =============================
void CAN1_TX_IRQHandler(void) {
	CAN_TX_Handling(&canHandle);
}

// =============================
// Simple delay
// =============================
void delay_ms(uint32_t ms) {
	for (uint32_t i = 0; i < ms; i++) {
		for (volatile uint32_t j = 0; j < 4000; j++)
			;
	}
}
