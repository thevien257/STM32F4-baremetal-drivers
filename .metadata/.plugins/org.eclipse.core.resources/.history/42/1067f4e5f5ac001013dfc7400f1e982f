#include <stdint.h>
#include "stm32f4xx_cus.h"
#include "stm32f4xx_cus_gpio.h"
#include "stm32f4xx_cus_can.h"
#include <stdio.h>

// =============================
// Function prototypes
// =============================
void CAN_GPIO_Init(void);
void CAN_IT_Mode_Init(void);
void GPIO_USER_INIT(void);

// Global CAN handles
CAN_HandleTypedef canHandle;
CAN_RXHandleTypeDef rxMsg;
GPIO_Handle_TypeDef GPIO_Handle;
uint8_t readInput;

int main(void) {
	// Initialize GPIO (button)
	GPIO_USER_INIT();

	// Enable CAN1 TX and RX0 interrupts
	IRQ_Config(CAN1_TX_IRQ19, ENABLE);
	IRQ_Config(CAN1_RX0_IRQ20, ENABLE);

	// Initialize CAN in interrupt mode
	CAN_IT_Mode_Init();

	// Enable RX interrupt for FIFO 0
	CAN_RECEIVE_IT(&canHandle, &rxMsg, CAN_FIFO_0);

	printf("STM32 CAN TX/RX Interrupt Mode Started\r\n");
	printf("Press button to send CAN message\r\n");
	printf("==============================\r\n\r\n");

	uint32_t messageCount = 0;

	while (1) {

		// Prepare TX message
		CAN_TXHandleTypeDef txMsg;
		txMsg.identifier = 0x123;
		txMsg.extd = CAN_STANDARD_IDE;
		txMsg.frameType = CAN_DATA_FRAME;
		txMsg.dataLengthCode = 8;

		// Fill data pattern
		txMsg.data[0] = 0xAA;
		txMsg.data[1] = 0xBB;
		txMsg.data[2] = 0xCC;
		txMsg.data[3] = 0xDD;
		txMsg.data[4] = (messageCount >> 24) & 0xFF;
		txMsg.data[5] = (messageCount >> 16) & 0xFF;
		txMsg.data[6] = (messageCount >> 8) & 0xFF;
		txMsg.data[7] = messageCount & 0xFF;

		printf("Sending CAN message #%lu...\r\n", ++messageCount);

		// Reset completion flag
		CAN_txCompl = LOW;

		// Send using interrupt mode
		CAN_SEND_IT(&canHandle, &txMsg);

		// Wait for transmission to complete
		while (CAN_txCompl != HIGH)
			;

		printf("Message sent successfully!\r\n\r\n");

		// Simple debounce delay
		for (volatile uint32_t i = 0; i < 1000000; i++)
			;
	}

	// ========== RECEIVE ==========
	if (CAN_rxCompl == HIGH) {
		printf("CAN Message Received (Interrupt)!\r\n");
		printf("  ID: 0x%03lX\r\n", rxMsg.identifier);
		printf("  Type: %s\r\n",
				rxMsg.extd == CAN_STANDARD_IDE ? "Standard" : "Extended");
		printf("  Frame: %s\r\n", rxMsg.rtr ? "Remote" : "Data");
		printf("  DLC: %d\r\n", rxMsg.dataLengthCode);
		printf("  Data: ");
		for (uint8_t i = 0; i < rxMsg.dataLengthCode; i++) {
			printf("0x%02X ", rxMsg.data[i]);
		}
		printf("\r\n==============================\r\n\r\n");

		// Reset completion flag
		CAN_rxCompl = LOW;

	}
}

// =============================
// GPIO Configuration for CAN (PD0, PD1)
// =============================
void CAN_GPIO_Init(void) {
	GPIO_Handle_TypeDef canTxPin;
	canTxPin.GPIOX = GPIOD;
	canTxPin.pin_number = GPIO_PIN_1;              // CAN1_TX = PD1
	canTxPin.mode = GPIO_MODE_AF;
	canTxPin.alternate_function_select = GPIO_AF9; // AF9 = CAN1
	canTxPin.output_type = GPIO_OUTPUT_TYPE_PP;
	canTxPin.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
	canTxPin.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&canTxPin);

	GPIO_Handle_TypeDef canRxPin;
	canRxPin.GPIOX = GPIOD;
	canRxPin.pin_number = GPIO_PIN_0;              // CAN1_RX = PD0
	canRxPin.mode = GPIO_MODE_AF;
	canRxPin.alternate_function_select = GPIO_AF9; // AF9 = CAN1
	canRxPin.output_type = GPIO_OUTPUT_TYPE_PP;
	canRxPin.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
	canRxPin.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&canRxPin);
}

// =============================
// CAN Interrupt Mode Initialization
// =============================
void CAN_IT_Mode_Init(void) {
	// Step 1: Init GPIO
	CAN_GPIO_Init();

	// Step 2: Configure CAN parameters
	canHandle.CANx = CAN1;
	canHandle.transmitPriority = 0;
	canHandle.receiveFIFOLockedMode = 0;
	canHandle.autoReTransmit = 1;
	canHandle.autoBusOff = 1;
	canHandle.bitrate = 1000000;                      // 1000 kbps
	canHandle.testModeSelected = CAN_NORMAL_MODE; // Loopback for testing

	// Step 3: Init CAN
	CAN_INIT(&canHandle);

	// Step 4: Configure filter to accept all frames
	CAN_FilterHandleTypeDef filterConfig;
	filterConfig.filterBank = 0;
	filterConfig.extd = CAN_STANDARD_IDE;
	filterConfig.fifoAssignment = CAN_FIFO_0;
	filterConfig.filterScale = CAN_FILTER_32_BIT_SCALE;
	filterConfig.filterMaskListMode = CAN_ID_MASK_MODE;
	filterConfig.CAN_Filter32BitMaskHandleTypeDef.id1 = 0x000;
	filterConfig.CAN_Filter32BitMaskHandleTypeDef.mask1 = 0x000; // Accept all IDs

	CAN_FILTER_CONFIG(&canHandle, &filterConfig);

	printf("CAN initialized in INTERRUPT mode\r\n");
	printf("Bitrate: 500 kbps\r\n");
	printf("Mode: Loopback\r\n\r\n");
}

// =============================
// GPIO Button Configuration (PA0)
// =============================
void GPIO_USER_INIT(void) {
	// PA0 - USER BUTTON
	GPIO_Handle.GPIOX = GPIOA;
	GPIO_Handle.mode = GPIO_MODE_INPUT;
	GPIO_Handle.pin_number = GPIO_PIN_0;
	GPIO_Handle.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&GPIO_Handle);
}

// =============================
// CAN1 TX Interrupt Handler
// =============================
void CAN1_TX_IRQHandler(void) {
	CAN_TX_Handling(&canHandle);
}

// =============================
// CAN1 RX0 Interrupt Handler
// =============================
void CAN1_RX0_IRQHandler(void) {
	CAN_RX_Handling(&canHandle, &rxMsg, CAN_FIFO_0);
}
