#include "stm32f4xx_cus.h"
#include <stdio.h>

// Function prototypes
void CAN_GPIO_Init(void);
void CAN_Normal_Mode_Init(void);
void delay_ms(uint32_t ms);

// Global CAN handle
CAN_HandleTypedef canHandle;

int main(void) {
    // Initialize CAN in normal mode
    CAN_Normal_Mode_Init();

    printf("STM32 CAN Transmitter Started\r\n");
    printf("==============================\r\n\r\n");

    uint32_t messageCount = 0;

    while (1) {
        // Prepare TX message
        CAN_TXHandleTypeDef txMsg;
        txMsg.identifier = 0x123;
        txMsg.extd = CAN_STANDARD_IDE;
        txMsg.frameType = CAN_DATA_FRAME;
        txMsg.dataLengthCode = 8;

        // Fill data with pattern
        txMsg.data[0] = 0xAA;
        txMsg.data[1] = 0xBB;
        txMsg.data[2] = 0xCC;
        txMsg.data[3] = 0xDD;
        txMsg.data[4] = 0x01;
        txMsg.data[5] = 0x02;
        txMsg.data[6] = 0x03;
        txMsg.data[7] = 0x04;

        // Send message
        printf("Sending CAN message #%lu...\r\n", ++messageCount);
        CAN_SEND(&canHandle, &txMsg);
        printf("âœ“ Message sent successfully!\r\n\r\n");

        // Delay between messages (1 second)
        delay_ms(1000);
    }
}

void CAN_GPIO_Init(void) {
    // Configure PD0 (CAN1_RX) and PD1 (CAN1_TX)
    GPIO_Handle_TypeDef canTxPin;
    canTxPin.GPIOX = GPIOD;
    canTxPin.pin_number = GPIO_PIN_1;              // CAN1_TX = PD1
    canTxPin.mode = GPIO_MODE_AF;                  // Alternate function
    canTxPin.alternate_function_select = GPIO_AF9; // AF9 = CAN1
    canTxPin.output_type = GPIO_OUTPUT_TYPE_PP;    // Push-pull
    canTxPin.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
    canTxPin.pull_up_pull_down = GPIO_PUPD_NO;     // No pull for CAN with transceiver
    GPIO_INIT(&canTxPin);

    GPIO_Handle_TypeDef canRxPin;
    canRxPin.GPIOX = GPIOD;
    canRxPin.pin_number = GPIO_PIN_0;              // CAN1_RX = PD0
    canRxPin.mode = GPIO_MODE_AF;                  // Alternate function
    canRxPin.alternate_function_select = GPIO_AF9; // AF9 = CAN1
    canRxPin.output_type = GPIO_OUTPUT_TYPE_PP;
    canRxPin.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
    canRxPin.pull_up_pull_down = GPIO_PUPD_NO;     // No pull for CAN with transceiver
    GPIO_INIT(&canRxPin);
}

void CAN_Normal_Mode_Init(void) {
    // Step 1: Initialize GPIO
    CAN_GPIO_Init();

    // Step 2: Configure CAN handle for NORMAL MODE
    canHandle.CANx = CAN1;
    canHandle.transmitPriority = 0;         // Priority by request order
    canHandle.receiveFIFOLockedMode = 0;    // Overwrite mode (not locked)
    canHandle.autoReTransmit = 1;           // Enable auto retransmission
    canHandle.autoBusOff = 1;               // Enable auto bus-off management
    canHandle.bitrate = 500000;             // 500 kbps (match with ESP32)
    canHandle.testModeSelected = 0;         // NORMAL MODE (no loopback/silent)

    // Step 3: Initialize CAN peripheral
    CAN_INIT(&canHandle);

    printf("CAN initialized in NORMAL mode\r\n");
    printf("Bitrate: 500 kbps\r\n\r\n");
}

void delay_ms(uint32_t ms) {
    // Rough delay - adjust based on your system clock
    // Assumes ~16 MHz clock, ~4 cycles per loop iteration
    for (uint32_t i = 0; i < ms; i++) {
        for (volatile uint32_t j = 0; j < 4000; j++)
            ;
    }
}
