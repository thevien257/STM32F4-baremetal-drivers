#include "stm32f4xx_cus_spi.h"

void SPI_PERIPHERAL_ENABLE(SPI_HandleTypedef *spi_handle, uint8_t EN) {
	if (EN == HIGH) {
		spi_handle->SPIx->CR1 |= (HIGH << Shift_6_pos);
	} else {
		spi_handle->SPIx->CR1 &= ~(HIGH << Shift_6_pos);
	}
}

void SPI_SSI_CONFIG(SPI_HandleTypedef *spi_handle, uint8_t EN) {
	if (EN == HIGH) {
		spi_handle->SPIx->CR1 |= (HIGH << Shift_8_pos);
	} else {
		spi_handle->SPIx->CR1 &= ~(HIGH << Shift_8_pos);
	}
}

void SPI_INIT(SPI_HandleTypedef *spi_handle) {
	if (spi_handle->SPIx == SPI1) {
		SPI1_EN();
	} else if (spi_handle->SPIx == SPI2) {
		SPI2_EN();
	} else if (spi_handle->SPIx == SPI3) {
		SPI3_EN();
	} else if (spi_handle->SPIx == SPI4) {
		SPI4_EN();
	} else if (spi_handle->SPIx == SPI5) {
		SPI5_EN();
	} else if (spi_handle->SPIx == SPI6) {
		SPI6_EN();
	}

	uint32_t tempreg = 0;

	// Master/Slave
	if (spi_handle->spi_master_slave == SPI_MASTER_MODE) {
		tempreg |= (HIGH << Shift_2_pos); // Set MSTR bit for master
	}

	// Simplex mode RX: we need to configure this because the communication happens only when master produces the clock, the clock happens when MOSI line has the data
	if (spi_handle->spi_data_direction == SPI_SIMPLEX_MODE_RX) {
		tempreg |= (HIGH << Shift_10_pos);
	}
	// Simplex mode TX: just remove the MISO line in full duplex mode

	// Half duplex mode:
	// In master mode, the MOSI pin is used while the MISO pin is used in slave mode.
	else if (spi_handle->spi_data_direction == SPI_HALF_DUPLEX_MODE) {
		tempreg |= (HIGH << Shift_15_pos);
	}
	// Full duplex mode or Simplex mode TX
	else {
		spi_handle->SPIx->CR1 &= ~(HIGH << Shift_15_pos);
		spi_handle->SPIx->CR1 &= ~(HIGH << Shift_10_pos);
	}

	// Configure baud rate
	spi_handle->SPIx->CR1 &= ~(BIT_111_MASK << Shift_3_pos);
	spi_handle->SPIx->CR1 |= (spi_handle->spi_sclk_prescaler << Shift_3_pos);

	// Select data frame
	spi_handle->SPIx->CR1 &= ~(HIGH << Shift_11_pos);
	spi_handle->SPIx->CR1 |= (spi_handle->spi_frame_format << Shift_11_pos);

	// Configure CPOL and CPHA
	// CPHA
	spi_handle->SPIx->CR1 &= ~(GPIO_BIT_11_Mask << Shift_0_pos);
	spi_handle->SPIx->CR1 |= (spi_handle->spi_clock_phase << Shift_0_pos);

	//CPOL
	spi_handle->SPIx->CR1 |= (spi_handle->spi_clock_polarity << Shift_1_pos);

	// Software slave management
	// Software
	if (spi_handle->spi_ssm == SPI_SOFTWARE_SLAVE_EN) {
		spi_handle->SPIx->CR1 &= ~(HIGH << Shift_9_pos);
		spi_handle->SPIx->CR1 |= (HIGH << Shift_9_pos);
		if (spi_handle->spi_master_slave == SPI_MASTER_MODE) {
			// Internal slave select HIGH
			SPI_SSI_CONFIG(spi_handle, HIGH);
		}
	} else {
		// Hardware slave management
		spi_handle->SPIx->CR1 &= ~(HIGH << Shift_9_pos); // Clear SSM bit
		// Hardware output enable
		if (spi_handle->spi_master_slave == SPI_MASTER_MODE) {
			spi_handle->SPIx->CR2 |= (HIGH << Shift_2_pos);
		} else if (spi_handle->spi_master_slave == SPI_SLAVE_MODE) {
			spi_handle->SPIx->CR2 &= ~(HIGH << Shift_2_pos);
		}
	}
}

void SPI_SEND(SPI_HandleTypedef *spi_handle, uint8_t *txBuffer, uint32_t len) {
	if (spi_handle->spi_data_direction == SPI_HALF_DUPLEX_MODE) {
		// If this is half duplex mode then want to sending data, then this is send only
		spi_handle->SPIx->CR1 |= (HIGH << Shift_14_pos);
	}
	// Enable SPI
	SPI_PERIPHERAL_ENABLE(spi_handle, HIGH);

	while (len > 0) {

		// Wait for TXE is empty
		while (!((spi_handle->SPIx->SR >> Shift_1_pos) & 0x1))
			;
		if (spi_handle->spi_frame_format == SPI_8_BIT_FRAME_FORMAT) {
			spi_handle->SPIx->DR = *txBuffer;
			len--;
			txBuffer++;
		} else if (spi_handle->spi_frame_format == SPI_16_BIT_FRAME_FORMAT) {
			spi_handle->SPIx->DR = *(uint16_t*) txBuffer;
			len--;
			len--;
			(uint16_t*) txBuffer++;
		}

	}

	// Wait for TXE is empty
	while (!((spi_handle->SPIx->SR >> Shift_1_pos) & 0x1))
		;

	// Wait until BSY=0
	while ((spi_handle->SPIx->SR >> Shift_7_pos) & 0x1)
		;

	// Disable SPI
	SPI_PERIPHERAL_ENABLE(spi_handle, LOW);
}
