/* Application: USART2 with Hardware Flow Control (RTS/CTS)
 * STM32F411CEU6 Black Pill
 * PA0 = CTS (input - Clear To Send from other device)
 * PA1 = RTS (output - Request To Send to other device)
 * PA2 = TX
 * PA3 = RX
 */

#include "stm32f4xx_cus.h"
#include <string.h>

void USART2_USER_INIT(void);
void GPIO_USER_INIT(void);

USART_HandleTypedef USART_Handle;
GPIO_Handle_TypeDef GPIO_Handle;

// Message to send
char *msg = "Hello this is from stm32f411ceu6\r\n";

// Buffer for received data
char rx_buf[100];

void delay(void) {
	for (uint32_t i = 0; i < 500000 / 2; i++)
		;
}

int main(void) {
	GPIO_USER_INIT();
	Get_APB1_Clock_Speed();  // USART2 is on APB1
	USART2_USER_INIT();
	IRQ_Config(USART2_IRQ38, HIGH);  // USART2 IRQ number is 38

	// Send initial message once
	USART_txCompl = 0;
	while (USART_write_IT(&USART_Handle, (uint8_t*) msg, strlen(msg))
			!= USART_READY_IT)
		;
	while (USART_txCompl == 0)
		;  // Wait for transmission complete

	// Start receiving continuously
	USART_rxCompl = 0;
	memset(rx_buf, 0, sizeof(rx_buf));
	while (USART_read_IT(&USART_Handle, (uint8_t*) rx_buf, 1) != USART_READY_IT)
		;

	uint8_t rx_index = 0;

	while (1) {
		// Check if data received
		if (USART_rxCompl == 1) {
			USART_rxCompl = 0;

			// Echo back the received byte
			USART_txCompl = 0;
			while (USART_write_IT(&USART_Handle, (uint8_t*) &rx_buf[rx_index],
					1) != USART_READY_IT)
				;
			while (USART_txCompl == 0)
				;

			// Move to next buffer position (circular)
			rx_index++;
			if (rx_index >= sizeof(rx_buf)) {
				rx_index = 0;
			}

			// Continue receiving next byte
			while (USART_read_IT(&USART_Handle, (uint8_t*) &rx_buf[rx_index], 1)
					!= USART_READY_IT)
				;
		}
	}

	return 0;
}

void USART2_USER_INIT(void) {
	USART_Handle.USARTx = USART2;
	USART_Handle.baud_rate = USART_BAUD_115200;
	USART_Handle.data_bits = USART_8_DATA_BITS;
	USART_Handle.stop_bits = USART_1_STOP_BIT;
	USART_Handle.oversampling_mode = USART_OVERSAMPLING_16;
	USART_Handle.parity_control = USART_PARITY_DISABLE;
	USART_Handle.usart_mode = USART_MODE_ASYNC;
	USART_Handle.usart_hardware_flow_control = USART_HW_FLOW_CTRL_RTS_CTS; // Enable RTS/CTS
	USART_INIT(&USART_Handle);
}

void GPIO_USER_INIT(void) {
	/* USART2 pins on GPIOA:
	 * PA0 = CTS (input)
	 * PA1 = RTS (output)
	 * PA2 = TX
	 * PA3 = RX
	 * All use AF7 (Alternate Function 7)
	 */

	GPIO_Handle.GPIOX = GPIOA;
	GPIO_Handle.alternate_function_select = GPIO_AF7;
	GPIO_Handle.mode = GPIO_MODE_AF;
	GPIO_Handle.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
	GPIO_Handle.output_type = GPIO_OUTPUT_TYPE_PP;
	GPIO_Handle.pull_up_pull_down = GPIO_PUPD_NONE; // No pull-up/down for UART with flow control

	// PA0 - CTS (input)
	GPIO_Handle.pin_number = GPIO_PIN_0;
	GPIO_INIT(&GPIO_Handle);

	// PA1 - RTS (output)
	GPIO_Handle.pin_number = GPIO_PIN_1;
	GPIO_INIT(&GPIO_Handle);

	// PA2 - TX
	GPIO_Handle.pin_number = GPIO_PIN_2;
	GPIO_INIT(&GPIO_Handle);

	// PA3 - RX
	GPIO_Handle.pin_number = GPIO_PIN_3;
	GPIO_INIT(&GPIO_Handle);
}

void USART2_IRQHandler(void) {
	USART_Handle_IT(&USART_Handle);
}

/* ============================================================================
 * ALTERNATIVE VERSION: With button on PC13 to trigger send
 * ============================================================================ */
#if 0

int main_with_button(void) {
    GPIO_USER_INIT();
    Get_APB1_Clock_Speed();
    USART2_USER_INIT();
    IRQ_Config(USART2_IRQ38, HIGH);

    // Setup button on PC13 (built-in button on Black Pill)
    GPIO_Handle.GPIOX = GPIOC;
    GPIO_Handle.pin_number = GPIO_PIN_13;
    GPIO_Handle.mode = GPIO_MODE_INPUT;
    GPIO_Handle.pull_up_pull_down = GPIO_PUPD_PU;
    GPIO_INIT(&GPIO_Handle);

    // Start receiving
    USART_rxCompl = 0;
    memset(rx_buf, 0, sizeof(rx_buf));
    while (USART_read_IT(&USART_Handle, (uint8_t*)rx_buf, 1) != USART_READY_IT);

    uint8_t rx_index = 0;

    while (1) {
        // Check for button press (PC13 is active LOW on Black Pill)
        if (!GPIO_INPUT(GPIOC, GPIO_PIN_13)) {
            delay();  // Debounce

            // Send message
            USART_txCompl = 0;
            while (USART_write_IT(&USART_Handle, (uint8_t*)msg, strlen(msg)) != USART_READY_IT);
            while (USART_txCompl == 0);

            // Wait for button release
            while (!GPIO_INPUT(GPIOC, GPIO_PIN_13));
            delay();
        }

        // Echo received data
        if (USART_rxCompl == 1) {
            USART_rxCompl = 0;

            USART_txCompl = 0;
            while (USART_write_IT(&USART_Handle, (uint8_t*)&rx_buf[rx_index], 1) != USART_READY_IT);
            while (USART_txCompl == 0);

            rx_index++;
            if (rx_index >= sizeof(rx_buf)) {
                rx_index = 0;
            }

            while (USART_read_IT(&USART_Handle, (uint8_t*)&rx_buf[rx_index], 1) != USART_READY_IT);
        }
    }

    return 0;
}

#endif

/* ============================================================================
 * PINOUT SUMMARY FOR USART2 WITH HARDWARE FLOW CONTROL
 * ============================================================================
 *
 * STM32F411CEU6 USART2 Pins:
 * ┌──────┬──────────┬───────────┬─────────────────────────┐
 * │ Pin  │ Function │ Direction │ Description             │
 * ├──────┼──────────┼───────────┼─────────────────────────┤
 * │ PA0  │ CTS      │ INPUT     │ Clear To Send (input)   │
 * │      │          │           │ Receives ready signal   │
 * │      │          │           │ from other device       │
 * ├──────┼──────────┼───────────┼─────────────────────────┤
 * │ PA1  │ RTS      │ OUTPUT    │ Request To Send (output)│
 * │      │          │           │ Tells other device      │
 * │      │          │           │ when we're ready        │
 * ├──────┼──────────┼───────────┼─────────────────────────┤
 * │ PA2  │ TX       │ OUTPUT    │ Transmit Data           │
 * ├──────┼──────────┼───────────┼─────────────────────────┤
 * │ PA3  │ RX       │ INPUT     │ Receive Data            │
 * └──────┴──────────┴───────────┴─────────────────────────┘
 *
 * All pins use AF7 (Alternate Function 7) for USART2
 *
 *
 * WIRING TO CONNECT WITH HAL STM32 (USART1):
 * ┌────────────────────────────────────────────────────────────┐
 * │ Custom Driver (USART2)    HAL Device (USART1)             │
 * │ ──────────────────────    ────────────────────             │
 * │ PA2 (TX)      ──────────> PA10 (RX)                        │
 * │ PA3 (RX)      <────────── PA9  (TX)                        │
 * │ PA0 (CTS)     <────────── PA12 (RTS)    [crossed!]         │
 * │ PA1 (RTS)     ──────────> PA11 (CTS)    [crossed!]         │
 * │ GND           ──────────── GND                             │
 * └────────────────────────────────────────────────────────────┘
 *
 * IMPORTANT: CTS/RTS must be crossed!
 * - Device1's RTS → Device2's CTS
 * - Device1's CTS ← Device2's RTS
 */
