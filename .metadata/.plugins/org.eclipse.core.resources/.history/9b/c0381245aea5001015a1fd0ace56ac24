/* USART1 Synchronous Master Example - Communicates with SPI Slave */
#include "stm32f4xx_cus.h"
#include <string.h>

void USART_USER_INIT();
void GPIO_USER_INIT();

USART_HandleTypedef USART_Handle;
GPIO_Handle_TypeDef GPIO_Handle;

// Messages to send to SPI slave
char *msg[3] = { "Hello Slave! ",      // 16 bytes
		"Data from USART", "Sync Mode Test!" };

// Reply from SPI slave stored here
char rx_buf[16];

uint32_t cnt = 0;

void delay(void) {
	for (uint32_t i = 0; i < 500000 / 2; i++)
		;
}

int main(void) {
	GPIO_USER_INIT();
	USART_USER_INIT();
	IRQ_Config(USART1_IRQ37, HIGH);  // USART1 IRQ

	printf("USART1 Synchronous Master Started\n");

	while (1) {
		delay();

		USART_rxCompl = 0;
		USART_txCompl = 0;

		cnt = cnt % 3;

		memset(rx_buf, 0, sizeof(rx_buf));

		// In synchronous mode, we must transmit to receive
		// Setup simultaneous TX and RX (like SPI full-duplex)
		while (USART_read_IT(&USART_Handle, (uint8_t*) rx_buf, strlen(msg[cnt]))
				!= USART_READY_IT)
			;

		while (USART_write_IT(&USART_Handle, (uint8_t*) msg[cnt],
				strlen(msg[cnt])) != USART_READY_IT)
			;

		// Wait for transmission complete
		while (USART_txCompl == 0)
			;

		printf("Sent: %s\n", msg[cnt]);

		// Wait for reception complete
		while (USART_rxCompl == 0)
			;

		rx_buf[15] = '\0';  // Null terminate
		printf("Received: %s\n\n", rx_buf);

		cnt++;
	}

	return 0;
}

void USART_USER_INIT() {
	USART_Handle.USARTx = USART1;                           // Changed to USART1
	USART_Handle.baud_rate = USART_BAUD_115200;
	USART_Handle.data_bits = USART_8_DATA_BITS;
	USART_Handle.stop_bits = USART_1_STOP_BIT;
	USART_Handle.oversampling_mode = USART_OVERSAMPLING_16;
	USART_Handle.parity_control = USART_PARITY_DISABLE;
	USART_Handle.usart_mode = USART_MODE_SYNC;
	USART_Handle.usart_cpol = USART_POLARITY_LOW;                    // CPOL = 0
	USART_Handle.usart_cpha = USART_PHASE_1EDGE;                     // CPHA = 0
	USART_Handle.last_bit_clock_pulse = 0x1;         // Clock pulse for last bit

	USART_Handle.usart_hardware_flow_control = USART_HW_FLOW_CTRL_NONE;
	USART_INIT(&USART_Handle);

	// Debug: Check RCC configuration
	printf("RCC->CFGR: 0x%lX\n", RCC->CFGR);
	printf("System Clock Source: %lu\n", (RCC->CFGR >> 2) & 0x3);
	printf("AHB Prescaler: %lu\n", (RCC->CFGR >> 4) & 0xF);
	printf("APB1 Prescaler: %lu\n", (RCC->CFGR >> 10) & 0x7);
	printf("APB2 Prescaler: %lu\n", (RCC->CFGR >> 13) & 0x7);

	USART_INIT(&USART_Handle);

	printf("APB2_Clock_Speed: %lu Hz\n", APB2_Clock_Speed);
	printf("BRR Register: 0x%lX\n", USART_Handle.USARTx->BRR);
	printf("Expected BRR for 115200: 0x%lX\n",
			(uint32_t) (APB2_Clock_Speed / 115200));
}

void GPIO_USER_INIT() {
	// USART1 pins - Use PB6/PB7 instead of PA9/PA10
	GPIO_Handle.GPIOX = GPIOB;  // Changed from GPIOA
	GPIO_Handle.alternate_function_select = GPIO_AF7;
	GPIO_Handle.mode = GPIO_MODE_AF;
	GPIO_Handle.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
	GPIO_Handle.output_type = GPIO_OUTPUT_TYPE_PP;
	GPIO_Handle.pull_up_pull_down = GPIO_PUPD_PU;

	GPIO_Handle.pin_number = GPIO_PIN_6;   // TX (was PIN_9)
	GPIO_INIT(&GPIO_Handle);
	GPIO_Handle.pin_number = GPIO_PIN_7;   // RX (was PIN_10)
	GPIO_INIT(&GPIO_Handle);

	// For synchronous mode, you might need CK on another pin
	// Check datasheet for USART1_CK alternate pin
	// Possibly PB5 or PA8 depending on your board
	GPIO_Handle.GPIOX = GPIOA;
	GPIO_Handle.pin_number = GPIO_PIN_8;   // CK
	GPIO_INIT(&GPIO_Handle);

	// User button (PA0)
	GPIO_Handle.pin_number = GPIO_PIN_0;
	GPIO_Handle.mode = GPIO_MODE_INPUT;
	GPIO_Handle.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&GPIO_Handle);
}

void USART1_IRQHandler(void) {                           // Changed handler name
	USART_Handle_IT(&USART_Handle);
}
