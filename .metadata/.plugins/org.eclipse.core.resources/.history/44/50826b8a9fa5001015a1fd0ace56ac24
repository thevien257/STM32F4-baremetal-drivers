/* USART2 Synchronous Master Example - Communicates with SPI Slave */
#include "stm32f4xx_cus.h"
#include <string.h>

void USART_USER_INIT();
void GPIO_USER_INIT();

USART_HandleTypedef USART_Handle;
GPIO_Handle_TypeDef GPIO_Handle;

// Messages to send to SPI slave
char *msg[3] = { "Hello Slave!   ",  // 16 bytes
		"Data from USART", "Sync Mode Test!" };

// Reply from SPI slave stored here
char rx_buf[16];

uint32_t cnt = 0;

void delay(void) {
	for (uint32_t i = 0; i < 500000 / 2; i++)
		;
}

int main(void) {
	GPIO_USER_INIT();
	Get_APB1_Clock_Speed();
	USART_USER_INIT();
	IRQ_Config(USART2_IRQ38, HIGH);  // USART2 IRQ

	printf("USART2 Synchronous Master Started\n");

	while (1) {
		delay();

		USART_rxCompl = 0;
		USART_txCompl = 0;

		cnt = cnt % 3;

		memset(rx_buf, 0, sizeof(rx_buf));

		// In synchronous mode, we must transmit to receive
		// Setup simultaneous TX and RX (like SPI full-duplex)
		while (USART_read_IT(&USART_Handle, (uint8_t*) rx_buf, 16)
				!= USART_READY_IT)
			;

		while (USART_write_IT(&USART_Handle, (uint8_t*) msg[cnt], 16)
				!= USART_READY_IT)
			;

		// Wait for transmission complete
		while (USART_txCompl == 0)
			;

		printf("Sent: %s\n", msg[cnt]);

		// Wait for reception complete
		while (USART_rxCompl == 0)
			;

		rx_buf[15] = '\0';  // Null terminate
		printf("Received: %s\n\n", rx_buf);

		cnt++;
	}

	return 0;
}

void GPIO_USER_INIT() {
	/* USART1 Synchronous Mode Pins:
	 * PA8  = CK  (Clock output - Master)
	 * PA9  = TX  (Transmit)
	 * PA10 = RX  (Receive)
	 */

	GPIO_Handle.GPIOX = GPIOA;
	GPIO_Handle.alternate_function_select = GPIO_AF7;
	GPIO_Handle.mode = GPIO_MODE_AF;
	GPIO_Handle.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
	GPIO_Handle.output_type = GPIO_OUTPUT_TYPE_PP;
	GPIO_Handle.pull_up_pull_down = GPIO_PUPD_NO;

	// PA8 - CK (Clock output)
	GPIO_Handle.pin_number = GPIO_PIN_8;
	GPIO_INIT(&GPIO_Handle);

	// PA9 - TX
	GPIO_Handle.pin_number = GPIO_PIN_9;
	GPIO_INIT(&GPIO_Handle);

	// PA10 - RX
	GPIO_Handle.pin_number = GPIO_PIN_10;
	GPIO_INIT(&GPIO_Handle);
}

void USART_USER_INIT() {
	USART_Handle.USARTx = USART1;
	USART_Handle.baud_rate = 115200;  // This sets the clock speed
	USART_Handle.data_bits = USART_8_DATA_BITS;
	USART_Handle.stop_bits = USART_1_STOP_BIT;
	USART_Handle.oversampling_mode = USART_OVERSAMPLING_16;
	USART_Handle.parity_control = USART_PARITY_DISABLE;

	/* SYNCHRONOUS MODE SETTINGS */
	USART_Handle.usart_mode = USART_MODE_SYNC;  // Enable synchronous mode

	/* Clock settings to match SPI slave:
	 * - CPOL = 0 (Clock polarity low when idle) -> matches SPI_POLARITY_LOW
	 * - CPHA = 0 (First edge) -> matches SPI_PHASE_1EDGE
	 * - LBCL = 1 (Last bit clock pulse) -> Generate clock for last data bit
	 */
	USART_Handle.usart_cpol = USART_POLARITY_LOW;   // Match SPI CPOL
	USART_Handle.usart_cpha = USART_PHASE_1EDGE;    // Match SPI CPHA
	USART_Handle.last_bit_clock_pulse = 0x1;        // Enable clock on last bit

	USART_Handle.usart_hardware_flow_control = USART_HW_FLOW_CTRL_NONE;

	USART_INIT(&USART_Handle);
}

void USART1_IRQHandler(void) {
	USART_Handle_IT(&USART_Handle);
}
