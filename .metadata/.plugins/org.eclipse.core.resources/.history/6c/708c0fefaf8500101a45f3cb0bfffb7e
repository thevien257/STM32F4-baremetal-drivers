#include "stm32f4xx_cus_gpio.h"

void GPIO_INIT(GPIO_Handle_TypeDef *gpioHandle) {
	// Enable clock source
	if (gpioHandle->GPIOX == GPIOA) {
		GPIOA_EN();
	} else if (gpioHandle->GPIOX == GPIOB) {
		GPIOB_EN();
	} else if (gpioHandle->GPIOX == GPIOC) {
		GPIOC_EN();
	} else if (gpioHandle->GPIOX == GPIOD) {
		GPIOD_EN();
	} else if (gpioHandle->GPIOX == GPIOE) {
		GPIOE_EN();
	} else if (gpioHandle->GPIOX == GPIOF) {
		GPIOF_EN();
	} else if (gpioHandle->GPIOX == GPIOG) {
		GPIOG_EN();
	} else if (gpioHandle->GPIOX == GPIOH) {
		GPIOH_EN();
	} else if (gpioHandle->GPIOX == GPIOI) {
		GPIOI_EN();
	}

	// Reset mode
	gpioHandle->GPIOX->MODER &= ~(GPIO_BIT_11_Mask
			<< (Shift_2_pos * gpioHandle->pin_number));
	// Pull-up or Pull-down
	gpioHandle->GPIOX->PUPDR &= ~(GPIO_BIT_11_Mask
			<< (Shift_2_pos * gpioHandle->pin_number));

	gpioHandle->GPIOX->PUPDR |= (gpioHandle->pull_up_pull_down
			<< (Shift_2_pos * gpioHandle->pin_number));
//	// Handle input mode
//	if (gpioHandle->mode == GPIO_MODE_INPUT) {
//
//	}
// Handle output mode
	if (gpioHandle->mode <= GPIO_MODE_OUTPUT) {
		// Set output mode
		gpioHandle->GPIOX->MODER |= (gpioHandle->mode
				<< (Shift_2_pos * gpioHandle->pin_number));

		// Set output type
		gpioHandle->GPIOX->OTYPER &= ~(GPIO_BIT_11_Mask
				<< (gpioHandle->pin_number));
		gpioHandle->GPIOX->OTYPER |= (gpioHandle->output_type)
				<< (gpioHandle->pin_number);

		// Set output speed
		gpioHandle->GPIOX->OSPEEDR &= ~(GPIO_BIT_11_Mask
				<< (Shift_2_pos * gpioHandle->pin_number));
		gpioHandle->GPIOX->OSPEEDR |= (gpioHandle->output_speed)
				<< (Shift_2_pos * gpioHandle->pin_number);
	} else if (gpioHandle->mode == GPIO_MODE_AF) {
		uint8_t ALT_low_high = (gpioHandle->pin_number / Divide_ALT_Function);
		uint8_t ALT_bit = (gpioHandle->pin_number % Divide_ALT_Function);
		gpioHandle->GPIOX->AFR[ALT_low_high] &= ~(GPIO_BIT_11_Mask
				<< gpioHandle->pin_number);
		gpioHandle->GPIOX->AFR[ALT_low_high] |=
				(gpioHandle->alternate_function_select << Shift_4_pos * ALT_bit);

	} else {
		// Interrupt mode
		SYSCFG_EN();
		// Configuration RISING/FALLING or RISING AND FALLING
		if (gpioHandle->mode == GPIO_MODE_INTERRUPT_CHANGE) {
			EXTI->RTSR &= ~(HIGH << gpioHandle->pin_number);
			EXTI->FTSR &= ~(HIGH << gpioHandle->pin_number);
			EXTI->RTSR |= (HIGH << gpioHandle->pin_number);
			EXTI->FTSR |= (HIGH << gpioHandle->pin_number);
		} else if (gpioHandle->mode == GPIO_MODE_INTERRUPT_FALLING) {
			EXTI->FTSR &= ~(HIGH << gpioHandle->pin_number);
			EXTI->FTSR |= (HIGH << gpioHandle->pin_number);
		} else if (gpioHandle->mode == GPIO_MODE_INTERRUPT_RISING) {
			EXTI->RTSR &= ~(HIGH << gpioHandle->pin_number);
			EXTI->RTSR |= (HIGH << gpioHandle->pin_number);
		}
		// Map EXTI to GPIO --> USING SYSCFG
		uint8_t cal_reg = (gpioHandle->pin_number / 4);
		uint8_t cal_bit = (gpioHandle->pin_number % 4);
		SYSCFG->EXTICR[cal_reg] |= (gpioHandle->exti_select << 4 * cal_bit);

		// Config Mask bit (Enable EXTI line)
		EXTI->IMR &= ~(HIGH << gpioHandle->pin_number);
		EXTI->IMR |= (HIGH << gpioHandle->pin_number);
	}
}

uint8_t GPIO_INPUT(GPIO_TypeDef *gpiox, uint8_t gpio_pins) {
	uint8_t val = ((gpiox->IDR >> gpio_pins) & GPIO_BIT_1_Mask);
	return val;
}

void GPIO_TOGGLE(GPIO_TypeDef *gpiox, uint8_t gpio_pins) {
	gpiox->ODR ^= (HIGH << gpio_pins);
}

void GPIO_OUTPUT(GPIO_TypeDef *gpiox, uint8_t gpio_pins, uint8_t val) {
	if (val == HIGH) {
		gpiox->BSRR |= (HIGH << gpio_pins);
	} else {
		gpiox->BSRR |= (HIGH << (Shift_16_pos + gpio_pins));
	}
}

void IRQ_Config(uint8_t IRQn, uint8_t priority, uint8_t EN) {
	// Enable the NVIC
	*ISER0 &= ~(HIGH << IRQn);
	*ISER1 &= ~(HIGH << IRQn);
	if (EN == ENABLE) {
		if (IRQn <= 31) {
			*ISER0 |= (HIGH << IRQn);
		} else if (IRQn > 31 && IRQn <= 63) {
			*ISER1 |= (HIGH << IRQn);
		}
	}
	IRQ_SetPriority(IRQn, priority);

}
void IRQ_SetPriority(uint8_t IRQn, uint8_t priority) {
	uint8_t cal_reg = IRQn / 4;
	uint8_t cal_bit = IRQn % 4;
	volatile uint32_t *cal_address_IPR = IPR_BASE_ADDR + Shift_4_pos * cal_reg;

	*cal_address_IPR &= ~(priority << (cal_bit * Shift_8_pos));
	*cal_address_IPR |= (priority << (cal_bit * Shift_8_pos));

}

