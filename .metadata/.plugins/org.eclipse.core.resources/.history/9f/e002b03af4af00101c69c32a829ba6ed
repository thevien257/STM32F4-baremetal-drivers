#include <stm32f4xx_cus_timer.h>

volatile uint32_t mil = 0;

void TIM_INIT(TIM_HandleTypeDef *timHandleTypeDef) {
	if (timHandleTypeDef->TIMx == TIM2) {
		TIM2_EN();
	} else if (timHandleTypeDef->TIMx == TIM3) {
		TIM3_EN();
	} else if (timHandleTypeDef->TIMx == TIM4) {
		TIM4_EN();
	} else if (timHandleTypeDef->TIMx == TIM5) {
		TIM5_EN();
	}

	// Ensure Counter is disable
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_0_pos);

	// Clock prescaler
	timHandleTypeDef->TIMx->PSC = timHandleTypeDef->prescaler;

	// Select Auto-reload value
	timHandleTypeDef->TIMx->ARR = timHandleTypeDef->autoReload;

	/*	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
	 TIM2->ARR = 1000;  // New value is buffered
	 // Counter continues using old ARR value until next overflow
	 // At next update event, ARR = 1000 takes effect
	 ```

	 ## Visual Example
	 ```
	 Without Preload:
	 CNT: 0 → 500 → 999 → 1000 (overflow)
	 You write ARR = 500 while CNT = 750
	 CNT: 750 → 751 → ... → 65535 → 0 → ... → 500 (finally overflows!) ❌

	 With Preload:
	 CNT: 0 → 500 → 999 → 1000 (overflow, new ARR loaded)
	 You write ARR = 500 while CNT = 750
	 CNT: 750 → 999 → 1000 (overflow with old ARR)
	 0 → 499 → 500 (now using new ARR) ✓*/

	// autoReloadPreload
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_7_pos);
	timHandleTypeDef->TIMx->CR1 |= (timHandleTypeDef->autoReloadPreload
			<< Shift_7_pos);

	// Select direction counter
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_4_pos);
	timHandleTypeDef->TIMx->CR1 |= (timHandleTypeDef->directionCounter
			<< Shift_4_pos);

	// Update disable
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_1_pos);
	timHandleTypeDef->TIMx->CR1 |= (timHandleTypeDef->updateDisable
			<< Shift_1_pos);

	// Update request source (Select source)
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_2_pos);
	timHandleTypeDef->TIMx->CR1 |= (timHandleTypeDef->updateRequestSource
			<< Shift_2_pos);

	// Timer enable
	timHandleTypeDef->TIMx->CR1 |= (HIGH << Shift_0_pos);

	/*	UG: Update generation
	 This bit can be set by software, it is automatically cleared by hardware.
	 0: No action
	 1: Re-initialize the counter and generates an update of the registers.*/
	timHandleTypeDef->TIMx->EGR |= (HIGH << Shift_0_pos);

	// Clear the update flag that was just set
	timHandleTypeDef->TIMx->SR &= ~(HIGH << Shift_0_pos);
}

void TIM_ENABLE(TIM_HandleTypeDef *timHandleTypeDef) {
	// Timer enable
	timHandleTypeDef->TIMx->CR1 |= (HIGH << Shift_0_pos);

	/*	UG: Update generation
	 This bit can be set by software, it is automatically cleared by hardware.
	 0: No action
	 1: Re-initialize the counter and generates an update of the registers.*/
	timHandleTypeDef->TIMx->EGR |= (HIGH << Shift_0_pos);

	// Clear the update flag that was just set
	timHandleTypeDef->TIMx->SR &= ~(HIGH << Shift_0_pos);
}

void TIM_DELAY_INIT(TIM_HandleTypeDef *timHandleTypeDef) {
	if (timHandleTypeDef->TIMx == TIM2) {
		TIM2_EN();
	} else if (timHandleTypeDef->TIMx == TIM3) {
		TIM3_EN();
	} else if (timHandleTypeDef->TIMx == TIM4) {
		TIM4_EN();
	} else if (timHandleTypeDef->TIMx == TIM5) {
		TIM5_EN();
	}

	Get_APB1_Clock_Speed();

	uint32_t psc = SystemClockSrc / ONE_MEGA_HERT;

	// Ensure Counter is disable
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_0_pos);

	// Clock prescaler
	timHandleTypeDef->TIMx->PSC = (psc - 1);

	// Select Auto-reload value (This will generate interrupt every 1ms for millis, but if use delay fuction then this ARR actually don't care)
	timHandleTypeDef->TIMx->ARR = 999;

	// autoReloadPreload
	timHandleTypeDef->TIMx->CR1 |= (HIGH << Shift_7_pos);

	// Count up
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_4_pos);

	// Enable update
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_1_pos);

	// Update request source (Select source)
	timHandleTypeDef->TIMx->CR1 &= ~(HIGH << Shift_2_pos);

	if (timHandleTypeDef->timerMode == TIM_INPUT_CAPTURE_MODE) {
		uint8_t channel = timHandleTypeDef->TIM_IC_HandleTypeDef.channel;
		uint8_t selection = timHandleTypeDef->TIM_IC_HandleTypeDef.selection;
		uint8_t prescaler = timHandleTypeDef->TIM_IC_HandleTypeDef.prescaler;
		uint8_t filter = timHandleTypeDef->TIM_IC_HandleTypeDef.filter;
		uint8_t polarity = timHandleTypeDef->TIM_IC_HandleTypeDef.polarity;
		uint8_t enableInt =
				timHandleTypeDef->TIM_IC_HandleTypeDef.enableInterrupt;

		if (channel == TIM_CHANNEL_1) {
			// CC1S[1:0]: Capture/Compare 1 selection (bits 1:0)
			timHandleTypeDef->TIMx->CCMR1 &= ~(GPIO_BIT_11_Mask << Shift_0_pos);
			timHandleTypeDef->TIMx->CCMR1 |= (selection << Shift_0_pos);

			// IC1PSC[1:0]: Input capture 1 prescaler (bits 3:2)
			timHandleTypeDef->TIMx->CCMR1 &= ~(GPIO_BIT_11_Mask << Shift_2_pos);
			timHandleTypeDef->TIMx->CCMR1 |= (prescaler << Shift_2_pos);

			// IC1F[3:0]: Input capture 1 filter (bits 7:4)
			timHandleTypeDef->TIMx->CCMR1 &= ~(0xF << Shift_4_pos);
			timHandleTypeDef->TIMx->CCMR1 |= (filter << Shift_4_pos);

			// Configure polarity: Clear CC1P (bit 1) and CC1NP (bit 3)
			timHandleTypeDef->TIMx->CCER &= ~((HIGH << Shift_1_pos)
					| (HIGH << Shift_3_pos));
			if (polarity == TIM_IC_FALLING_EDGE) {
				timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_1_pos); // CC1P = 1
			} else if (polarity == TIM_IC_BOTH_EDGES) {
				timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_1_pos)
						| (HIGH << Shift_3_pos);
			}
			// Rising edge: both bits = 0 (default)

			// CC1E: Enable capture on channel 1 (bit 0)
			timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_0_pos);

			// Enable interrupt if requested
			if (enableInt) {
				timHandleTypeDef->TIMx->DIER |= (HIGH << Shift_1_pos); // CC1IE
			}

		} else if (channel == TIM_CHANNEL_2) {
			// CC2S[1:0]: Capture/Compare 2 selection (bits 9:8)
			timHandleTypeDef->TIMx->CCMR1 &= ~(GPIO_BIT_11_Mask << Shift_8_pos);
			timHandleTypeDef->TIMx->CCMR1 |= (selection << Shift_8_pos);

			// IC2PSC[1:0]: Input capture 2 prescaler (bits 11:10)
			timHandleTypeDef->TIMx->CCMR1 &=
					~(GPIO_BIT_11_Mask << Shift_10_pos);
			timHandleTypeDef->TIMx->CCMR1 |= (prescaler << Shift_10_pos);

			// IC2F[3:0]: Input capture 2 filter (bits 15:12)
			timHandleTypeDef->TIMx->CCMR1 &= ~(0xF << Shift_12_pos);
			timHandleTypeDef->TIMx->CCMR1 |= (filter << Shift_12_pos);

			// Configure polarity: Clear CC2P (bit 5) and CC2NP (bit 7)
			timHandleTypeDef->TIMx->CCER &= ~((HIGH << Shift_5_pos)
					| (HIGH << Shift_7_pos));
			if (polarity == TIM_IC_FALLING_EDGE) {
				timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_5_pos); // CC2P = 1
			} else if (polarity == TIM_IC_BOTH_EDGES) {
				timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_5_pos)
						| (HIGH << Shift_7_pos);
			}

			// CC2E: Enable capture on channel 2 (bit 4)
			timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_4_pos);

			// Enable interrupt if requested
			if (enableInt) {
				timHandleTypeDef->TIMx->DIER |= (HIGH << Shift_2_pos); // CC2IE
			}

		} else if (channel == TIM_CHANNEL_3) {
			// CC3S[1:0]: Capture/Compare 3 selection (bits 1:0 of CCMR2)
			timHandleTypeDef->TIMx->CCMR2 &= ~(GPIO_BIT_11_Mask << Shift_0_pos);
			timHandleTypeDef->TIMx->CCMR2 |= (selection << Shift_0_pos);

			// IC3PSC[1:0]: Input capture 3 prescaler (bits 3:2)
			timHandleTypeDef->TIMx->CCMR2 &= ~(GPIO_BIT_11_Mask << Shift_2_pos);
			timHandleTypeDef->TIMx->CCMR2 |= (prescaler << Shift_2_pos);

			// IC3F[3:0]: Input capture 3 filter (bits 7:4)
			timHandleTypeDef->TIMx->CCMR2 &= ~(0xF << Shift_4_pos);
			timHandleTypeDef->TIMx->CCMR2 |= (filter << Shift_4_pos);

			// Configure polarity: Clear CC3P (bit 9) and CC3NP (bit 11)
			timHandleTypeDef->TIMx->CCER &= ~((HIGH << Shift_9_pos)
					| (HIGH << Shift_11_pos));
			if (polarity == TIM_IC_FALLING_EDGE) {
				timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_9_pos); // CC3P = 1
			} else if (polarity == TIM_IC_BOTH_EDGES) {
				timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_9_pos)
						| (HIGH << Shift_11_pos);
			}

			// CC3E: Enable capture on channel 3 (bit 8)
			timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_8_pos);

			// Enable interrupt if requested
			if (enableInt) {
				timHandleTypeDef->TIMx->DIER |= (HIGH << Shift_3_pos); // CC3IE
			}

		} else if (channel == TIM_CHANNEL_4) {
			// CC4S[1:0]: Capture/Compare 4 selection (bits 9:8 of CCMR2)
			timHandleTypeDef->TIMx->CCMR2 &= ~(GPIO_BIT_11_Mask << Shift_8_pos);
			timHandleTypeDef->TIMx->CCMR2 |= (selection << Shift_8_pos);

			// IC4PSC[1:0]: Input capture 4 prescaler (bits 11:10)
			timHandleTypeDef->TIMx->CCMR2 &=
					~(GPIO_BIT_11_Mask << Shift_10_pos);
			timHandleTypeDef->TIMx->CCMR2 |= (prescaler << Shift_10_pos);

			// IC4F[3:0]: Input capture 4 filter (bits 15:12)
			timHandleTypeDef->TIMx->CCMR2 &= ~(0xF << Shift_12_pos);
			timHandleTypeDef->TIMx->CCMR2 |= (filter << Shift_12_pos);

			// Configure polarity: Clear CC4P (bit 13) and CC4NP (bit 15)
			timHandleTypeDef->TIMx->CCER &= ~((HIGH << Shift_13_pos)
					| (HIGH << Shift_15_pos));
			if (polarity == TIM_IC_FALLING_EDGE) {
				timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_13_pos); // CC4P = 1
			} else if (polarity == TIM_IC_BOTH_EDGES) {
				timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_13_pos)
						| (HIGH << Shift_15_pos);
			}

			// CC4E: Enable capture on channel 4 (bit 12)
			timHandleTypeDef->TIMx->CCER |= (HIGH << Shift_12_pos);

			// Enable interrupt if requested
			if (enableInt) {
				timHandleTypeDef->TIMx->DIER |= (HIGH << Shift_4_pos); // CC4IE
			}
		}

	}
}

void TIM_MILLIS_INIT(TIM_HandleTypeDef *timHandleTypeDef) {
	TIM_DELAY_INIT(timHandleTypeDef);
	timHandleTypeDef->TIMx->DIER |= (HIGH << Shift_0_pos);

	if (timHandleTypeDef->TIMx == TIM2) {
		IRQ_Config(TIM2_IRQ28, HIGH);
	} else if (timHandleTypeDef->TIMx == TIM3) {
		IRQ_Config(TIM3_IRQ29, HIGH);
	} else if (timHandleTypeDef->TIMx == TIM4) {
		IRQ_Config(TIM4_IRQ30, HIGH);
	} else if (timHandleTypeDef->TIMx == TIM5) {
		IRQ_Config(TIM5_IRQ50, HIGH);
	}
}

uint32_t millis() {
	return mil;
}

void TIM_Handling(TIM_HandleTypeDef *timHandleTypeDef) {
	if (((timHandleTypeDef->TIMx->SR) >> Shift_0_pos) & 0x1) {
		// Clear the update flag that was just set
		timHandleTypeDef->TIMx->SR &= ~(HIGH << Shift_0_pos);
		mil++;
	}
}

void delay_us(TIM_HandleTypeDef *timHandleTypeDef, uint32_t us) {
	timHandleTypeDef->TIMx->CNT = 0;

	while (timHandleTypeDef->TIMx->CNT < us)
		;
}

void delay_ms(TIM_HandleTypeDef *timHandleTypeDef, uint32_t ms) {
	for (uint32_t i = 0; i < ms; i++) {
		delay_us(timHandleTypeDef, 1000);
	}
}
