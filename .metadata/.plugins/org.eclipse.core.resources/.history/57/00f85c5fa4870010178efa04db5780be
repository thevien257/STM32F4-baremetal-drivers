#include <stm32f4xx_cus_i2c.h>

void I2C_INIT(I2C_Handle_TypeDef *i2c_handle) {
	if (i2c_handle->I2Cx == I2C1) {
		I2C1_EN();
	} else if (i2c_handle->I2Cx == I2C2) {
		I2C2_EN();
	} else if (i2c_handle->I2Cx == I2C3) {
		I2C3_EN();
	}
	Get_APB1_Clock_Speed();

	// Master mode
	if (i2c_handle->MasterOrSlave == I2C_Master_Mode) {
		// Peripheral Clock Frequency (16Mhz)
		i2c_handle->I2Cx->CR2 &= ~(Five_BIT_1 << 0);
		i2c_handle->I2Cx->CR2 |= (Shift_16_pos << 0);

		// I2C Standard/Fast Mode
		i2c_handle->I2Cx->CCR &= ~(HIGH << Shift_15_pos);
		i2c_handle->I2Cx->CCR |= (i2c_handle->mode << Shift_15_pos);

		// Tscl = Thigh + Tlow
		if (i2c_handle->mode == I2C_Standard_Mode) {
			i2c_handle->I2Cx->CCR |= ((SystemClockSrc
					/ (2 * i2c_handle->scl_speed)) << 0);
			// Trise
			i2c_handle->I2Cx->TRISE = 0;
			i2c_handle->I2Cx->TRISE |= ((SystemClockSrc / 1000000)) + 1;
		} else if (i2c_handle->mode == I2C_Fast_Mode) {
			i2c_handle->I2Cx->CCR &= ~(HIGH << Shift_14_pos);
			i2c_handle->I2Cx->CCR |= (i2c_handle->duty_cycle << Shift_14_pos);
			if (i2c_handle->duty_cycle == I2C_Duty_Cycle_2) {
				i2c_handle->I2Cx->CCR |= ((SystemClockSrc
						/ (3 * i2c_handle->scl_speed)) << 0);
			} else if (i2c_handle->duty_cycle == I2C_Duty_Cycle_16_9) {
				i2c_handle->I2Cx->CCR |= ((SystemClockSrc
						/ (25 * i2c_handle->scl_speed)) << 0);
			}
			// Trise
			i2c_handle->I2Cx->TRISE |= ((SystemClockSrc
					* I2C_TRISE_MAX_FAST_MODE / 1000000000)) + 1;
		}

		// ACK bit En
		i2c_handle->I2Cx->CR1 &= ~(HIGH << Shift_10_pos);
		i2c_handle->I2Cx->CR1 |= (i2c_handle->ack_en << Shift_10_pos);

// Adress mode - 7 bit
		if (i2c_handle->address_select_bit == I2C_7_Bit_Adress) {
			i2c_handle->I2Cx->OAR1 |= (i2c_handle->address << HIGH);
		}
		i2c_handle->I2Cx->OAR1 |= (HIGH << Shift_14_pos);
	}

	// Enable Peripheral
	i2c_handle->I2Cx->CR1 |= (HIGH << Shift_0_pos);
// Slave mode
}

void I2C_Write(I2C_Handle_TypeDef *i2c_handle, uint8_t addr, uint8_t *data,
		uint32_t size) {
	// Setting start_bit
	i2c_handle->I2Cx->CR1 |= (HIGH << Shift_8_pos);

	while (!((i2c_handle->I2Cx->SR1 >> Shift_0_pos) & HIGH))
		;

	// Clear Start bit by reading SR1 register
	uint32_t read;
	read = i2c_handle->I2Cx->SR1;
	(void) read;
	I2C_Address(i2c_handle, addr, I2C_WRITE_BIT);

	// Check Address matched or not
	while (!((i2c_handle->I2Cx->SR1 >> Shift_1_pos) & HIGH))
		;

	read = i2c_handle->I2Cx->SR1;
	read = i2c_handle->I2Cx->SR2;
	(void) read;

	// LSB first for example uint8_t *data = {H, E, L, L, O}
	for (uint32_t i = 0; i < size; i++) {
		// Wait for data register is empty
		while (!((i2c_handle->I2Cx->SR1 >> Shift_7_pos) & HIGH))
			;
		i2c_handle->I2Cx->DR = data[i];
	}

	// Wait for TXE = 1: Data register is empty
	while (!((i2c_handle->I2Cx->SR1 >> Shift_7_pos) & HIGH))
		;
	// Wait for BTF = 1: Data byTe transfer succeeded
	while (!((i2c_handle->I2Cx->SR1 >> Shift_2_pos) & HIGH))
		;

	// Stop request
	i2c_handle->I2Cx->CR1 |= (HIGH << Shift_9_pos);
}

void I2C_Read(I2C_Handle_TypeDef *i2c_handle, uint8_t addr, uint8_t *data,
		uint8_t size) {

	// Setting start_bit
	i2c_handle->I2Cx->CR1 |= (HIGH << Shift_8_pos);

	while (!((i2c_handle->I2Cx->SR1 >> Shift_0_pos) & HIGH))
		;

	// Clear Start bit by reading SR1 register
	uint32_t read;
	read = i2c_handle->I2Cx->SR1;
	(void) read;
	I2C_Address(i2c_handle, addr, I2C_READ_BIT);

	// Check Address matched or not
	while (!((i2c_handle->I2Cx->SR1 >> Shift_1_pos) & HIGH))
		;

	if (size == 1) {

		// Set ACK LOW

		//Clear ADDR Flag
		read = i2c_handle->I2Cx->SR1;
		read = i2c_handle->I2Cx->SR2;
		(void) read;

		// Wait for data register is not empty (Receiver)
		while (!((i2c_handle->I2Cx->SR1 >> Shift_6_pos) & HIGH))
			;

		// Stop request
		i2c_handle->I2Cx->CR1 |= (HIGH << Shift_9_pos);

		//Read data
		data[0] = i2c_handle->I2Cx->DR;
		return;

	} else if (size > 1) {
		//Clear ADDR Flag
		read = i2c_handle->I2Cx->SR1;
		read = i2c_handle->I2Cx->SR2;
		(void) read;
		for (uint32_t i = 0; i < size; i++) {
			// Wait for data register is not empty (Receiver)
			while (!((i2c_handle->I2Cx->SR1 >> Shift_6_pos) & HIGH))
				;
			if ((size - i) == 1) {

				// Set ACK LOW

				// Stop request
				i2c_handle->I2Cx->CR1 |= (HIGH << Shift_9_pos);
			}
			data[i] = i2c_handle->I2Cx->DR;
		}
	}

}

void I2C_Address(I2C_Handle_TypeDef *i2c_handle, uint8_t addr, uint8_t rnw) {
	uint8_t slave_addr = addr << 1;
	if (rnw == I2C_WRITE_BIT) {
		slave_addr &= ~(HIGH);
	} else if (rnw == I2C_READ_BIT) {
		slave_addr |= (HIGH);
	}

	i2c_handle->I2Cx->DR = slave_addr;

}

