#include "stm32f4xx_cus_spi.h"
#include "stm32f4xx_cus_gpio.h"
#include <string.h>
// SPI2 Pins Configuration:
// PB12 -> NSS (Slave Select)
// PB13 -> SCK (Clock)
// PB14 -> MISO (Master In Slave Out)
// PB15 -> MOSI (Master Out Slave In)

SPI_HandleTypedef spi2_slave;
uint8_t rxBuffer[32];
uint8_t txBuffer[32] = "Hello from STM32!";

void SPI2_GPIO_Init(void) {
	GPIO_Handle_TypeDef spi_pins;

	// Configure PB12 (NSS) as AF
	spi_pins.GPIOX = GPIOB;
	spi_pins.pin_number = GPIO_PIN_12;
	spi_pins.mode = GPIO_MODE_AF;
	spi_pins.alternate_function_select = GPIO_AF5;  // AF5 for SPI2
	spi_pins.output_type = GPIO_OUTPUT_TYPE_PP;
	spi_pins.output_speed = GPIO_OUTPUT_SPEED_HIGH;
	spi_pins.pull_up_pull_down = GPIO_PUPD_PU;  // Pull-up for NSS
	GPIO_INIT(&spi_pins);

	// Configure PB13 (SCK) as AF
	spi_pins.pin_number = GPIO_PIN_13;
	spi_pins.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&spi_pins);

	// Configure PB14 (MISO) as AF
	spi_pins.pin_number = GPIO_PIN_14;
	GPIO_INIT(&spi_pins);

	// Configure PB15 (MOSI) as AF
	spi_pins.pin_number = GPIO_PIN_15;
	GPIO_INIT(&spi_pins);
}

void SPI2_Slave_Init(void) {
	spi2_slave.SPIx = SPI2;
	spi2_slave.spi_master_slave = SPI_SLAVE_MODE;
	spi2_slave.spi_data_direction = SPI_FULL_DUPLEX_MODE;
	spi2_slave.spi_frame_format = SPI_8_BIT_FRAME_FORMAT;
	spi2_slave.spi_clock_polarity = SPI_IDLE_LOW;  // CPOL = 0
	spi2_slave.spi_clock_phase = SPI_DATA_CAPTURED_FIRST_CLOCK;  // CPHA = 0
	spi2_slave.spi_ssm = SPI_SOFTWARE_SLAVE_DIS;  // Hardware NSS management
	spi2_slave.spi_sclk_prescaler = SPI_PRES_2;  // Don't care for slave

	SPI_INIT(&spi2_slave);
}

int main(void) {
	uint8_t rxData[32];
	uint8_t txData[32] = "STM32 Slave Data";

	// Initialize GPIO for SPI2
	SPI2_GPIO_Init();

	// Initialize SPI2 as Slave
	SPI2_Slave_Init();

	// CRITICAL: Enable SPI BEFORE master starts communication
	SPI_PERIPHERAL_ENABLE(&spi2_slave, HIGH);

	while (1) {
		// Prepare data for transmission
		memcpy(txData, "Hello Arduino!", 15);

		// Wait for NSS to go LOW (master selects slave)
		// This ensures we're ready before master starts
		while (GPIOB->IDR & (1 << 12))
			;  // Wait for PB12 (NSS) LOW

		// Now perform full duplex communication
		SPI_SendReceive_FullDuplex(&spi2_slave, txData, rxData, 16);

		// Wait for NSS to go HIGH (master releases slave)
		while (!(GPIOB->IDR & (1 << 12)))
			;  // Wait for PB12 (NSS) HIGH

		// Process received data here
		// rxData now contains data from Arduino

		// Small delay before ready for next transaction
		for (volatile uint32_t i = 0; i < 1000; i++)
			;
	}
}
