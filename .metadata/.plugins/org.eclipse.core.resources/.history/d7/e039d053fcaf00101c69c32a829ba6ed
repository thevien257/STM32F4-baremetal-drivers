#include <stdint.h>
#include <main.h>

GPIO_Handle_TypeDef gpio_handle;
TIM_HandleTypeDef tim_ic_handle;
TIM_HandleTypeDef tim_delay_handle;

// ✅ MUST be volatile for interrupt variables!
volatile uint32_t captureValue1 = 0;
volatile uint32_t captureValue2 = 0;
volatile uint8_t captureReady = 0;
volatile uint8_t firstCapture = 1;

// Debug variables
volatile uint32_t debugDifference = 0;
volatile uint8_t debugOverflow = 0;

void GPIO_USER_INIT(void);
void TIMER_IC_USER_INIT(void);

int main(void) {
	// Enable FPU
	SCB->CPACR |= ((3UL << 20) | (3UL << 22));
	__asm volatile ("DSB");
	__asm volatile ("ISB");

	GPIO_USER_INIT();
	TIMER_IC_USER_INIT();

	float frequency = 0;
	uint32_t printCounter = 0;

	printf("Starting frequency measurement with interrupt mode...\r\n");

	while (1) {
		// Generate test signal on PA8
		GPIO_OUTPUT(GPIOA, GPIO_PIN_8, HIGH);
		delay_us(&tim_delay_handle, 500);  // 500μs HIGH
		GPIO_OUTPUT(GPIOA, GPIO_PIN_8, LOW);
		delay_us(&tim_delay_handle, 500);  // 500μs LOW

		// ✅ ONLY check captureReady flag - don't check TIM_IC_GetFlag!
		if (captureReady) {
			captureReady = 0;  // Clear flag

			uint32_t difference;
			uint32_t cap1, cap2;
			uint8_t overflowOccurred = 0;

			// ✅ Copy volatile variables to local (atomic read)
			cap1 = captureValue1;
			cap2 = captureValue2;

			// Ensure captures are valid and different
			if (captureValue2 > captureValue1) {
				difference = captureValue2 - captureValue1;

				// Calculate frequency (assuming 1MHz timer)
				float frequency = 1000000.0f / difference;

				printf("Valid Measurement: Diff=%lu, Frequency=%.2f Hz\n",
						difference, frequency);
			} else {
				printf("Invalid capture sequence\n");
			}

			// Debug prints
			debugDifference = difference;
			debugOverflow = overflowOccurred;

			// Calculate frequency
			if (difference > 0) {
				// Assuming 1MHz timer clock (1μs per tick)
				// Frequency = 1,000,000 / (time between edges in μs)
				frequency = 1000000.0f / difference;

				// Optional: Add lower and upper bound sanity checks
				if (frequency > 0.1f && frequency < 100000.0f) {
					// Print every 100th measurement
					if (++printCounter >= 100) {
						printCounter = 0;
						printf(
								"Frequency: %.2f Hz (Diff: %lu, Overflow: %s)\r\n",
								frequency, difference,
								overflowOccurred ? "YES" : "NO");
					}
				} else {
					// Unusual frequency, might indicate measurement error
					printf("Unusual frequency: %.2f Hz (Diff: %lu)\r\n",
							frequency, difference);
				}
			} else {
				printf("Invalid measurement: difference = 0\r\n");
			}
		}
	}
}

void GPIO_USER_INIT(void) {
	// PA8 - OUTPUT (generates test signal)
	gpio_handle.GPIOX = GPIOA;
	gpio_handle.pin_number = GPIO_PIN_8;
	gpio_handle.mode = GPIO_MODE_OUTPUT;
	gpio_handle.output_speed = GPIO_OUTPUT_SPEED_HIGH;
	gpio_handle.output_type = GPIO_OUTPUT_TYPE_PP;
	gpio_handle.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&gpio_handle);

	// PA0 - INPUT CAPTURE (TIM2_CH1)
	gpio_handle.GPIOX = GPIOA;
	gpio_handle.pin_number = GPIO_PIN_0;
	gpio_handle.mode = GPIO_MODE_AF;
	gpio_handle.alternate_function_select = GPIO_AF1;  // TIM2
	gpio_handle.output_speed = GPIO_OUTPUT_SPEED_HIGH;
	gpio_handle.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&gpio_handle);
}

void TIMER_IC_USER_INIT(void) {
	// TIM2 for input capture
	tim_ic_handle.TIMx = TIM2;
	tim_ic_handle.timerMode = TIM_INPUT_CAPTURE_MODE;
	tim_ic_handle.prescaler = 15;  // 16MHz / 16 = 1MHz (1μs per tick)
	tim_ic_handle.autoReload = 0xFFFFFFFF;  // Max for 32-bit TIM2
	tim_ic_handle.directionCounter = TIM_COUNT_UP;
	tim_ic_handle.autoReloadPreload = LOW;
	tim_ic_handle.updateDisable = LOW;
	tim_ic_handle.updateRequestSource = LOW;

	// Input capture configuration
	tim_ic_handle.TIM_IC_HandleTypeDef.channel = TIM_CHANNEL_1;
	tim_ic_handle.TIM_IC_HandleTypeDef.polarity = TIM_IC_RISING_EDGE;
	tim_ic_handle.TIM_IC_HandleTypeDef.selection = TIM_IC_SELECTION_TI1;
	tim_ic_handle.TIM_IC_HandleTypeDef.prescaler = TIM_ICPSC_DIV1;
	tim_ic_handle.TIM_IC_HandleTypeDef.filter = TIM_IC_FILTER_NONE;
	tim_ic_handle.TIM_IC_HandleTypeDef.enableInterrupt = ENABLE; // ✅ Enable interrupt!

	TIM_INIT(&tim_ic_handle);

	// TIM3 for delay functions
	tim_delay_handle.TIMx = TIM3;
	TIM_DELAY_INIT(&tim_delay_handle);
	TIM_ENABLE(&tim_delay_handle);

	printf("Timers initialized.\r\n");
}

void TIM2_IRQHandler(void) {
	if (TIM_IC_GetFlag(&tim_ic_handle, TIM_CHANNEL_1)) {
		// Print debug information about each capture
		printf("IRQ: firstCapture=%d, Capture1=%lu, Capture2=%lu\n",
				firstCapture, captureValue1, captureValue2);

		if (firstCapture) {
			captureValue1 = TIM_IC_ReadCapture(&tim_ic_handle, TIM_CHANNEL_1);
			firstCapture = 0;
		} else {
			uint32_t newCapture = TIM_IC_ReadCapture(&tim_ic_handle,
			TIM_CHANNEL_1);

			// Debug print to verify capture logic
			printf("New capture: %lu, Previous capture: %lu\n", newCapture,
					captureValue1);

			// Only update if new capture is different
			if (newCapture != captureValue1) {
				captureValue2 = newCapture;
				captureReady = 1;
			}
		}

		// Clear the capture flag
		TIM_IC_ClearFlag(&tim_ic_handle, TIM_CHANNEL_1);
	}
}
