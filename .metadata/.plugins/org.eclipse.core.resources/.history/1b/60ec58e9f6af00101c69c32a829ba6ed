#include <stdint.h>
#include <main.h>

GPIO_Handle_TypeDef gpio_input, gpio_output;
TIM_HandleTypeDef tim_ic_handle;

volatile uint32_t captureValue1 = 0;
volatile uint32_t captureValue2 = 0;
volatile uint8_t captureReady = 0;
volatile uint8_t firstCapture = 1;

void GPIO_USER_INIT(void);
void TIMER_IC_USER_INIT(void);

int main(void) {
	GPIO_USER_INIT();
	TIMER_IC_USER_INIT();

	float frequency = 0;

	while (1) {
		// Generate test signal on PA8
		GPIO_OUTPUT(GPIOA, GPIO_PIN_8, HIGH);
		delay_us(&tim_ic_handle, 500);  // 500μs HIGH
		GPIO_OUTPUT(GPIOA, GPIO_PIN_8, LOW);
		delay_us(&tim_ic_handle, 500);  // 500μs LOW
		// This creates 1kHz square wave (period = 1000μs)

		// Check if capture ready
		if (captureReady) {
			captureReady = 0;

			uint32_t timeDiff;
			if (captureValue2 >= captureValue1) {
				timeDiff = captureValue2 - captureValue1;
			} else {
				timeDiff = (0xFFFFFFFF - captureValue1) + captureValue2 + 1;
			}

			if (timeDiff > 0) {
				frequency = 1000000.0f / timeDiff;
				// Should read approximately 1000 Hz
			}
		}
	}
}

void GPIO_USER_INIT(void) {
	// PA8 - OUTPUT (generates test signal)
	gpio_output.GPIOX = GPIOA;
	gpio_output.pin_number = GPIO_PIN_8;
	gpio_output.mode = GPIO_MODE_OUTPUT;
	gpio_output.output_speed = GPIO_OUTPUT_SPEED_HIGH;
	gpio_output.output_type = GPIO_OUTPUT_TYPE_PP;
	gpio_output.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&gpio_output);

	// PA0 - INPUT CAPTURE (TIM2_CH1)
	gpio_input.GPIOX = GPIOA;
	gpio_input.pin_number = GPIO_PIN_0;
	gpio_input.mode = GPIO_MODE_AF;
	gpio_input.alternate_function_select = GPIO_AF1;
	gpio_input.output_speed = GPIO_OUTPUT_SPEED_HIGH;
	gpio_input.pull_up_pull_down = GPIO_PUPD_NONE;
	GPIO_INIT(&gpio_input);
}

void TIMER_IC_USER_INIT(void) {
	tim_ic_handle.TIMx = TIM2;
	tim_ic_handle.timerMode = TIM_INPUT_CAPTURE_MODE;

	tim_ic_handle.TIM_IC_HandleTypeDef.channel = TIM_CHANNEL_1;
	tim_ic_handle.TIM_IC_HandleTypeDef.polarity = TIM_IC_RISING_EDGE;
	tim_ic_handle.TIM_IC_HandleTypeDef.selection = TIM_IC_SELECTION_TI1;
	tim_ic_handle.TIM_IC_HandleTypeDef.prescaler = TIM_ICPSC_DIV1;
	tim_ic_handle.TIM_IC_HandleTypeDef.filter = TIM_IC_FILTER_NONE;
	tim_ic_handle.TIM_IC_HandleTypeDef.enableInterrupt = ENABLE;

	TIM_DELAY_INIT(&tim_ic_handle);
	TIM_ENABLE(&tim_ic_handle);
}

void TIM2_IRQHandler(void) {
	if (TIM_IC_GetFlag(&tim_ic_handle, TIM_CHANNEL_1)) {
		if (firstCapture) {
			captureValue1 = TIM_IC_ReadCapture(&tim_ic_handle, TIM_CHANNEL_1);
			firstCapture = 0;
		} else {
			captureValue2 = TIM_IC_ReadCapture(&tim_ic_handle, TIM_CHANNEL_1);
			captureReady = 1;
			captureValue1 = captureValue2;
		}

		TIM_IC_ClearFlag(&tim_ic_handle, TIM_CHANNEL_1);
	}
}
