#include "stm32f4xx_cus.h"
#include <string.h>

void USART_USER_INIT();
void GPIO_USER_INIT();

USART_HandleTypedef USART_Handle;
GPIO_Handle_TypeDef GPIO_Handle;

//we have 3 different messages that we transmit to arduino
//you can by all means add more messages
char *msg[3] = { "hihihihihihi123", "Hello How are you ?", "Today is Monday !" };

//reply from arduino will be stored here
char rx_buf[1024];

uint8_t g_data = 0;
uint32_t cnt = 0;

void delay(void) {
	for (uint32_t i = 0; i < 500000 / 2; i++)
		;
}

int main(void) {
	GPIO_USER_INIT();
	Get_APB1_Clock_Speed();
	USART_USER_INIT();
	IRQ_Config(USART2_IRQ38, HIGH);
//	UART_RECEIVER_ENABLE(&USART_Handle, HIGH);
//	UART_TRANSMIT_ENABLE(&USART_Handle, HIGH); // needed for printf()

	printf("Application is running\n");

	while (1) {
		// Wait for button press (PA0)
		while (!GPIO_INPUT(GPIOA, GPIO_PIN_0))
			;

		delay();  // debounce

		USART_rxCompl = 0;
		USART_txCompl = 0;

		// Next message index ; make sure that cnt value doesn't cross 2
		cnt = cnt % 3;

		memset(rx_buf, 0, sizeof(rx_buf));  // Clear buffer first

		// Setup READ Interrupt
		while (USART_read_IT(&USART_Handle, rx_buf, strlen(msg[cnt]))
				!= USART_READY_IT)
			;

		// Setup WRITE Interrupt
		while (USART_write_IT(&USART_Handle, (uint8_t*) msg[cnt],
				strlen(msg[cnt])) != USART_READY_IT)
			;

		while (USART_txCompl == 0)
			;

//		USART_write(&USART_Handle, (uint8_t*) msg[cnt], strlen(msg[cnt]));

		printf("Transmitted : %s\n", msg[cnt]);

		while (USART_rxCompl == 0)
			;

		//just make sure that last byte should be null otherwise %s fails while printing
		rx_buf[strlen(msg[cnt])] = '\0';

		//Print what we received from the arduino
		printf("Received    : %s\n", rx_buf);

		//move on to next message indexed in msg[]
		cnt++;

	}

	return 0;
}

void GPIO_USER_INIT() {
	// USART2 pins (PA2 = TX, PA3 = RX)
	GPIO_Handle.GPIOX = GPIOA;
	GPIO_Handle.alternate_function_select = GPIO_AF7;
	GPIO_Handle.mode = GPIO_MODE_AF;
	GPIO_Handle.output_speed = GPIO_OUTPUT_SPEED_VERY_HIGH;
	GPIO_Handle.output_type = GPIO_OUTPUT_TYPE_PP;
	GPIO_Handle.pull_up_pull_down = GPIO_PUPD_PU;

	// PA0 - CTS (input)
	GPIO_Handle.pin_number = GPIO_PIN_0;
	GPIO_INIT(&GPIO_Handle);

	// PA1 - RTS (output)
	GPIO_Handle.pin_number = GPIO_PIN_1;
	GPIO_INIT(&GPIO_Handle);

	// PA2 - TX
	GPIO_Handle.pin_number = GPIO_PIN_2;
	GPIO_INIT(&GPIO_Handle);

	// PA3 - RX
	GPIO_Handle.pin_number = GPIO_PIN_3;
	GPIO_INIT(&GPIO_Handle);
}

void USART2_USER_INIT(void) {
	USART_Handle.USARTx = USART2;
	USART_Handle.baud_rate = USART_BAUD_115200;
	USART_Handle.data_bits = USART_8_DATA_BITS;
	USART_Handle.stop_bits = USART_1_STOP_BIT;
	USART_Handle.oversampling_mode = USART_OVERSAMPLING_16;
	USART_Handle.parity_control = USART_PARITY_DISABLE;
	USART_Handle.usart_mode = USART_MODE_ASYNC;
	USART_Handle.usart_hardware_flow_control = USART_HW_FLOW_CTRL_RTS_CTS; // Enable RTS/CTS
	USART_INIT(&USART_Handle);
}

void USART2_IRQHandler(void) {
	USART_Handle_IT(&USART_Handle);
}

/* ============================================================================
 * ALTERNATIVE VERSION: Print complete lines (better for reading messages)
 * ============================================================================ */
#if 0

int main_print_lines(void) {
    GPIO_USER_INIT();
    Get_APB1_Clock_Speed();
    USART2_USER_INIT();
    IRQ_Config(USART2_IRQ38, HIGH);

    printf("Application started - waiting for data...\n");

    // Send initial message once
    USART_txCompl = 0;
    while (USART_write_IT(&USART_Handle, (uint8_t*)msg, strlen(msg)) != USART_READY_IT);
    while (USART_txCompl == 0);

    printf("Sent: %s", msg);

    // Start receiving
    USART_rxCompl = 0;
    memset(rx_buf, 0, sizeof(rx_buf));
    while (USART_read_IT(&USART_Handle, (uint8_t*)rx_buf, 1) != USART_READY_IT);

    uint8_t rx_index = 0;

    while (1) {
        if (USART_rxCompl == 1) {
            USART_rxCompl = 0;

            // Check for line endings
            if (rx_buf[rx_index] == '\r' || rx_buf[rx_index] == '\n') {
                if (rx_index > 0) {
                    rx_buf[rx_index] = '\0';  // Null terminate
                    printf("Received complete message: %s\n", rx_buf);

                    // Echo back the complete line
                    USART_txCompl = 0;
                    while (USART_write_IT(&USART_Handle, (uint8_t*)rx_buf, rx_index) != USART_READY_IT);
                    while (USART_txCompl == 0);

                    // Send line ending
                    char line_end[] = "\r\n";
                    USART_txCompl = 0;
                    while (USART_write_IT(&USART_Handle, (uint8_t*)line_end, 2) != USART_READY_IT);
                    while (USART_txCompl == 0);

                    // Reset buffer
                    memset(rx_buf, 0, sizeof(rx_buf));
                    rx_index = 0;
                }
            } else {
                // Regular character - just move to next position
                rx_index++;
                if (rx_index >= sizeof(rx_buf) - 1) {
                    printf("Buffer full! Message: %s\n", rx_buf);
                    memset(rx_buf, 0, sizeof(rx_buf));
                    rx_index = 0;
                }
            }

            // Continue receiving next byte
            while (USART_read_IT(&USART_Handle, (uint8_t*)&rx_buf[rx_index], 1) != USART_READY_IT);
        }
    }

    return 0;
}

#endif

/* ============================================================================
 * ALTERNATIVE VERSION: With button on PC13 to trigger send
 * ============================================================================ */
#if 0

int main_with_button(void) {
    GPIO_USER_INIT();
    Get_APB1_Clock_Speed();
    USART2_USER_INIT();
    IRQ_Config(USART2_IRQ38, HIGH);

    // Setup button on PC13 (built-in button on Black Pill)
    GPIO_Handle.GPIOX = GPIOC;
    GPIO_Handle.pin_number = GPIO_PIN_13;
    GPIO_Handle.mode = GPIO_MODE_INPUT;
    GPIO_Handle.pull_up_pull_down = GPIO_PUPD_PU;
    GPIO_INIT(&GPIO_Handle);

    // Start receiving
    USART_rxCompl = 0;
    memset(rx_buf, 0, sizeof(rx_buf));
    while (USART_read_IT(&USART_Handle, (uint8_t*)rx_buf, 1) != USART_READY_IT);

    uint8_t rx_index = 0;

    while (1) {
        // Check for button press (PC13 is active LOW on Black Pill)
        if (!GPIO_INPUT(GPIOC, GPIO_PIN_13)) {
            delay();  // Debounce

            // Send message
            USART_txCompl = 0;
            while (USART_write_IT(&USART_Handle, (uint8_t*)msg, strlen(msg)) != USART_READY_IT);
            while (USART_txCompl == 0);

            // Wait for button release
            while (!GPIO_INPUT(GPIOC, GPIO_PIN_13));
            delay();
        }

        // Echo received data
        if (USART_rxCompl == 1) {
            USART_rxCompl = 0;

            USART_txCompl = 0;
            while (USART_write_IT(&USART_Handle, (uint8_t*)&rx_buf[rx_index], 1) != USART_READY_IT);
            while (USART_txCompl == 0);

            rx_index++;
            if (rx_index >= sizeof(rx_buf)) {
                rx_index = 0;
            }

            while (USART_read_IT(&USART_Handle, (uint8_t*)&rx_buf[rx_index], 1) != USART_READY_IT);
        }
    }

    return 0;
}

#endif

/* ============================================================================
 * PINOUT SUMMARY FOR USART2 WITH HARDWARE FLOW CONTROL
 * ============================================================================
 *
 * STM32F411CEU6 USART2 Pins:
 * ┌──────┬──────────┬───────────┬─────────────────────────┐
 * │ Pin  │ Function │ Direction │ Description             │
 * ├──────┼──────────┼───────────┼─────────────────────────┤
 * │ PA0  │ CTS      │ INPUT     │ Clear To Send (input)   │
 * │      │          │           │ Receives ready signal   │
 * │      │          │           │ from other device       │
 * ├──────┼──────────┼───────────┼─────────────────────────┤
 * │ PA1  │ RTS      │ OUTPUT    │ Request To Send (output)│
 * │      │          │           │ Tells other device      │
 * │      │          │           │ when we're ready        │
 * ├──────┼──────────┼───────────┼─────────────────────────┤
 * │ PA2  │ TX       │ OUTPUT    │ Transmit Data           │
 * ├──────┼──────────┼───────────┼─────────────────────────┤
 * │ PA3  │ RX       │ INPUT     │ Receive Data            │
 * └──────┴──────────┴───────────┴─────────────────────────┘
 *
 * All pins use AF7 (Alternate Function 7) for USART2
 *
 *
 * WIRING TO CONNECT WITH HAL STM32 (USART1):
 * ┌────────────────────────────────────────────────────────────┐
 * │ Custom Driver (USART2)    HAL Device (USART1)             │
 * │ ──────────────────────    ────────────────────             │
 * │ PA2 (TX)      ──────────> PA10 (RX)                        │
 * │ PA3 (RX)      <────────── PA9  (TX)                        │
 * │ PA0 (CTS)     <────────── PA12 (RTS)    [crossed!]         │
 * │ PA1 (RTS)     ──────────> PA11 (CTS)    [crossed!]         │
 * │ GND           ──────────── GND                             │
 * └────────────────────────────────────────────────────────────┘
 *
 * IMPORTANT: CTS/RTS must be crossed!
 * - Device1's RTS → Device2's CTS
 * - Device1's CTS ← Device2's RTS
 */
